<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java常见面试题]]></title>
    <url>%2Fpost%2F44e3c230.html</url>
    <content type="text"><![CDATA[逐步更新中. Java基础常见面试题(待补充)Spring常见面试题(仅常见)1. 你对Spring有什么了解(Really? 要这么问?) Spring是一个java企业级应用的轻量级开源开发框架. 简化了java应用开发. Spring的核心是IOC和AOP 2. Spring的IOC和AOP IOC是控制反转, Spring通过控制反转实现了松散耦合, 将对象的依赖交由Spring进行管理 AOP是面向切面, Spring通过切面把应用业务逻辑和系统服务分开, 比如日志切面. 3. 核心容器Application Context(上下文)​ Application Context是Spring中较高级的容器, 底层也是继承了BeanFactory, 可以加载XML中的bean, 将其集中起来, 在有请求的时候分配bean. ​ 常见的实现类有: 1. ClassPathXmlApplicationContext: 默认为项目的classpath相对路径. 2. FileSystemXmlApplicationContext: 默认为项目的工作路径, 即项目的根目录. 3. XmlWebApplicationContext: 默认为项目的/WEB-INF/目录下. 4. AOP是什么, 原理, 配置, 场景 AOP把应用分成两个部分: 核心关注点和横切关注点, 业务主要处理的是核心关注点, 与其关系不大的部分是横切关注点. 主要作用在于分离系统中的各种关注点. AOP的原理在于Spring的动态代理, 这样不会对代码进行修改, 而是在内存中生成AOP代理对象, 在特定切点做增强处理, 并回调原对象的方法. 代理方式分两种: JDK动态代理和CGLIB动态代理, 不同的是JDK的动态代理是通过反射来接收被代理的类, 且要求和被代理类实现一个接口, 核心是InvocationHandler接口和Proxy类. 如果目标类没有实现该接口, 则会用CGLIB来动态代理目标类, CGLIB是通过运行时动态生成某个类的子类, 所以如果目标类是final则无法进行代理. 可以通过@Aspect标记切面, 其他的注解有@Pointcut定义切点, @Round, @Before, @After, @AfterReturning, @AfterThrowing. 执行顺序也是如此. AOP的场景可以有事务管理, 日志, 缓存, 权限等. 5. IOC​ IOC负责创建对象, 管理对象(通过DI, 依赖注入), 装配对象, 配置对象, 并管理这些对象的生命周期. 6. BeanFactory和Application Context的区别​ Application Context提供一种方法处理文本消息, 通常表现为加载文件资源. 而且继承了MessageSource接口, 可以实现可插拔的方式提供获取本地化消息的方法. 7. Spring框架中的单例bean是线程安全的吗?​ 不是 8. @Autowired和@Resource的区别 Autowired是由Spring提供, 默认按类型装配, 且要求依赖对象必须存在, 可以通过设置required属性为false来允许null值, 想使用名称装配可以使用@Qualifier注解 Resource是JDK1.6支持的注解, 默认按照名称装配.名称可以通过name属性指定, 如果没有则默认去字段名进行名称查找. 两个注解在便利程度上是相同的. 9. Spring支持的事务管理类型 编程式事务管理: 可以通过编程的方式管理事务, 灵活但难以维护. 声明式事务管理: 将业务代码和事务管理分开, 只需要注解和XML配置来管理事务.(推荐) 10. SpringMVC的请求流程​ 用户发送请求, DispatcherServlet接收请求, 通过映射处理器适配到对应的Handler, 调用响应方法处理, 返回视图, 经过视图解析和渲染返回给用户. 11. @Controller和@RestController的区别​ @RestController相当于@ResponseBody + @Controller, 不能返回页面. Spring Boot常见面试题(近常见)1. SpringBoot是什么? 和SpringMVC有什么区别?​ SpringBoot是由Spring开源组织Pivotal基于Spring开发的开源框架, 是Spring组件的一站式解决方案, 简化了Spring繁琐的配置, 提供了各种启动器. 可以独立运行, 无代码和XML生成, 简化配置, 自动配置等. 2. SpringBoot的核心配置有什么? 区别是什么? application和bootstrap, 可以是yml或者properties. yml不支持@PropertySource注解导入配置. application是主要配置文件, 用于自动配置. bootstrap一般用于Spring Cloud配置, 一些固定不能被覆盖的属性, 一些加密/解密的场景. 加载顺序在application之前. 3. SpringBoot的核心注解是哪个? 都包含什么功能?​ @SpringBootApplication @SpringBootConfiguration, 实现配置文件的功能. @EnableAutoConfiguration, 开启自动配置, 也可以添加属性exclude关闭某个自动配置功能. @ComponentScan, 组件扫描. 4. SpringBoot的自动配置原理​ 在MATA-INF下面有Spring.factories文件, 都是需要自动配置的类. 启动时会读取这个文件进行自动配置. 5. 怎么在SpringBoot服务启动时加载一些代码 @PostContrust, java原生注解, 属于构造器注入, 在类被加载时执行 ApplicationRunner接口, 启动获取应用启动时的参数. CommandLineRunner接口, 启动获取命令行参数. 可以通过实现Orderd接口或者@Order注解来实现启动顺序. 6. SpringBoot读取配置的方式 @PropertySource @Value @Environment @ConfigurationProperties 7. 实现热部署的方式 Spring Loaded Spring-boot-devtools Spring Cloud常见面试题(拙见, 较少)1. SpringCloud和Dubbo的区别 SpringCloud在调用方式上使用Rest API, Dubbo使用RPC远程调用, 在微服务中, RPC对于服务提供方和调用方来说依赖太高, 容易出现版本错误, Rest为轻量级接口, 不存在代码之间的耦合, 比RPC更加灵活. 功能上SpringCloud有20多个子项目, Dubbo近实现了服务治理. SpringCloud使用Netflix的Eureka作为注册中心, Dubbo使用ZooKeeper. SpringCloud在社区活跃以及生态上比Dubbo要强的多. 2. Eureka和ZooKeeper的区别 ZooKeeper保证的是CP(一致性和分区容错性), Eureka保证的是AP(高可用和分区容错) ZooKeeper在选举期间注册服务瘫痪, 虽然服务最终会恢复, 但是选取期间不可用. Eureka各个节点平等, 有一个就可以保证可用, 但是查到的数据不是最新的. Eureka的自我保护机制, ZooKeeper反而会导致整个注册系统瘫痪 Eureka不再从注册列表移除因心跳而应该过期的服务. Eureka仍然会接受新服务的注册和查询请求, 但不会被同步到其他节点.(高可用) 当网络稳定时, 新的注册信息会被同步到其他节点.(最终一致性) 4. SpringCloud中如何独立通讯 远程过程调用(RPI), 也就是服务的注册和发现, 直接通过远程过程调用访问别的Service 优点: 简单, 没有中间件代理, 系统更简洁. 缺点: 只支持请求/响应, 不支持比如通知, 异步响应, 发布/订阅, 订阅的异步响应. 消息, 使用异步消息通讯, 服务和服务之间通过消息管道. 优点: 可用性高, 也支持请求/响应, 不支持比如通知, 异步响应, 发布/订阅, 订阅的异步响应等. 缺点: 消息中间件的额外复杂性. 5. 服务熔断和服务降级 服务降级一般指服务在高并发下产生了阻塞, 导致当前线程不可用, 服务器的线程全部堵塞, 导致服务器的崩溃. 当某个服务调用响应时间过长或不可用占用资源达到一定阈值, 根据业务进行一些策略上的不处理或者简单处理, 释放资源保证核心服务的正常运转. 常见的降级情况有: 超时降级, 失败次数降级, 故障降级, 限流降级. 熔断一般指某个服务故障或者异常等异常条件时, 熔断器打开, 直接熔断整个服务, 进入指定的熔断逻辑, 在请求时直接返回fallback的值, 而不是一直等待超时或者一直报错. 经过一段时间后, 熔断器会进入半开状态, 允许通过一个请求, 当调用成功时, 熔断器恢复关闭状态, 请求失败则继续保持打开, 直到下一个半开时间. 6. 微服务技术栈都有哪些? 服务开发: Spring, SpringBoot, SpringMVC 注册中心: Netflix-Eureka, ZooKeeper 服务调用: Rest, RPC 熔断: Hystrix 负载均衡: Ribbon, Nginx 服务接口调用: Dubbo, Feign 消息队列: Kafka, RabbitMQ等 配置中心: SpringCloudConfig 网关: Zuul 消息总线: SpringCloudBus Dubbo常见面试题Netty常见面试题Mybatis常见面试题(都是一些常见简单的)1. #{}和${}的区别​ #{}解析传递进来的参数数据, ${}则是原样拼接. ​ #{}是预编译处理, 可以有效的防止SQL注入, ${}是字符串替换. 2. 当实体类中的属性名和表中的字段名不一样 通过在查询的sql语句中定义字段名的别名, 使其和实体类的属性名一致. 通过\做字段映射(一般是首选) 3. 如何在插入后获取主键​ 通过selectKey, 执行select LAST_INSERT_ID()获取 4. 在mapper中如何传递多个参数 #{0}, #{1}按照顺序指定(不推荐) 通过@Param(name), @Param(code)指定#{name}, #{code} 通过map, 用法同2, 需指定parameterType=”map” 5. 动态sql, 都有哪些标签, 执行原理 动态sql是在XML映射文件或者代码中, 通过条件判断动态拼接出来的sql. Mybatis提供了9种动态sql标签: trim, where, set, foreach, if, choose, when, otherwise, bind 执行原理是使用OGNL从sql参数对象中计算表达式的值, 再根据值动态拼接sql. 6. 在xml映射文件中, 不同的xml映射文件id是否可以重复​ 如果配置了namespace可以. 7. dao接口和xml的映射工作原理是什么? 能否重载? dao接口(mapper接口)的全限名, 就是映射文件的namespace, 接口中的方法就是映射文件中MappedStatement的id值, 接口方法中的参数就是传递给sql的参数. 工作原理是JDK的动态代理, 运行时会为接口生成代理对象, 代理对象拦截接口方法, 转而执行MappedStatement所代表的sql, 然后返回结果. 不可以重载. 因为全限名+方法名是映射的寻找策略. 8. Mybatis的分页和分页插件的分页有什么区别? Mybatis的分页是通过针对ResultSet结果集执行的内存分页. 分页插件是通过Mybatis提供的插件接口, 拦截sql进行物理分页的参数拼接(limit x, y). MySQL常见面试题]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springboot</tag>
        <tag>springcloud</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm的学习笔记]]></title>
    <url>%2Fpost%2Fd6b23368.html</url>
    <content type="text"><![CDATA[JVM是java的核心和基础, 介于java编译器和操作系统之间的虚拟处理器. java编译器通过编译java源代码, 得到JVM能理解的代码或字节码文件, 通过JVM将每一条指令翻译成不同平台的机器码, 通过平台运行. 一 JVM执行程序的过程: 加载 .class 文件 管理并分配内存 执行垃圾收集 二 类加载的过程: 类加载是指通过类的全限定名获取类的二进制字节流, 将字节流代表的静态存储结构转化为方法区的运行时数据结构. 在内存中生成这个类的class对象 加载, 通过类的全限定名获取类的二进制字节流. 连接, 包括: 验证class文件中字节流包含的信息符合当前虚拟机要求, 且不危害虚拟机自身安全. 正式为类变量分配内存并设置类变量初始值. 将常量池的符号引用替换为直接引用 根据程序员意愿初始化类变量. 三 对象的内存划分 对象头: 包含mark world和类型指针 mark world包含hash码, GC分代年龄, 锁状态标志等. 类型指针是用来确定这个对象是哪个类的实例. 实例数据: 是对象存储的真正有效信息. 对齐填充: hostspot虚拟机要求对象的大小必须是8字节的整数倍. 四 JVM的内存划分 线程独享区 java栈: 存放栈帧, 每个栈帧对应被调用的一个方法, 其中包括局部变量表, 操作数栈, 指向运行时常量池的引用, 方法返回地址等. 本地方法栈 与java栈作用和原理类似, 不过执行的都是本地方法. 程序计数器 保存程序当前执行的指令地址. 线程共享区 堆 用来存储对象和数组 方法区 存储类信息, 静态变量, 常量, 编译后的代码. 五 运行时常量池和字符串常量池的区别(intern)在new String(), 或调用intern方法时, 如果字符串常量池中不存在, 就会创建一个, 有则直接返回已存在的. 在JDK1.6, 字符串常量池和运行时常量池都在方法区. 自1.7开始, 字符串常量池被移动到堆中. 六 内存泄漏和内存溢出 内存泄漏: 分配出去的内存无法被回收 常见的分析策略是查看当前的内存分配, 找出占用内存居高不下的对象, 在代码中进行优化. 内存溢出: 程序需要分配的内存超过了系统能分配的范围. 七 GC中如何判断对象是否存活 引用计数: 略 可达性分析法: 到GC Root可达, 判定为不可回收的对象. GC Root是虚拟机栈, 本地方法栈, 方法区静态属性, 方法区常量所引用的对象 八 垃圾收集算法 标记-清除算法: 标记所有对象, 标记完统一回收. 效率不高, 且容易产生碎片 复制算法: 将内存划分成一块大的Eden空间(80%)和两块小的Survivor空间(10%), 每次使用Eden和其中一块Survivor, 回收时, 将两者中存活的对象复制到空闲的Survivor中, 清空之前用到的空间. 如果这块Survivor空间不够, 使用分配担保机制, 将多出的对象存在老年代. 标记-整理算法: 标记出所有对象, 回收时让存活的对象向一端移动, 直接清理端边界外的内存. 分代收集算法: java堆分为新生代和老年代, 垃圾回收时, 新生代采用复制算法, 处理大量需要回收的对象, 老年代存活的对象较多, 使用标记-清除或者标记-整理. 九 常见的垃圾收集器 Serial: 单线程收集器 ParNew: 新生代收集器, Serial的多线程版本 Parallel Scavenge: 新生代收集器, 采用复制算法, 实现最大吞吐量 Serial Old: Serial的老年代版本 Parallel Old: ParNew的老年代版本 CMS: 以获取最短停顿时间为目标的收集器 初始标记: 标记GC Root能直接关联到的对象 并发标记: 进行GC Root Tracing 重新标记: 修正并发标记期间用户线程继续工作导致的标记变动 并发清除: 清除未被标记的对象 G1: 独立管理整个gc堆 ( 初始标记, 并发标记, 最终标记, 筛选回收 ) 十 什么情况下对象会进入老年代 大对象(需要大量连续空间的对象), 常见的为很长的字符串或者数组 长期存活的对象, 每度过一次Minor GC, 年龄+1, 增长到一定程度(默认为15, 可以通过MaxTenuringThreshold设置), 进入老年代 动态年龄判断, 如果Survivor空间某个年龄的对象累计大小超出了其空间的一半(默认为50%, 可以通过TargetSurvivorRatio设置), 则大于或等于该年龄的对象都会进入老年代 空间分配担保: 复制算法中会将无法容纳的对象进行处理 十一 GC进行GC的时间是无法直接控制的, 只有当Eden区满了会出发minor GC, 老年代满了或调用System.gc会进行full GC. 不过需要注意的是, 此函数建议JVM进行主GC, 虽然只是建议而非一定, 但很多情况下它会触发主GC, 从而增加主GC的频率, 也即增加了间歇性停顿的次数]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清理Twitter]]></title>
    <url>%2Fpost%2Fbb1895ee.html</url>
    <content type="text"><![CDATA[常年搁置的Twitter账号总是被拿去做广告, 转发各种垃圾推文. 辣么如何在找回之后清理呢. 使用方法很简单, 不过不是全自动哦. Step 1, 清理推文 进到主页https://twitter.com/yourAccount 在头像的右侧选择Tweets标签(一般默认就是这里), 然后一直下拉到底部, 因为清理的只是当前显示的. 右键检查或者F12进入控制台, 选择Console, 粘贴并执行下面的脚本, 等待一会就OK了. 1$(&quot;.js-actionDelete&quot;).each(function()&#123;$(this).click()$(&quot;.delete-action&quot;).get(0).click()&#125;) Step 2, 清理转推 刷新页面. 剩下的这些没有删除提示的就是转推了. 同样一直下拉到底部, 粘贴脚本, 执行, 等一会就可以了1$(&quot;.js-actionRetweet&quot;).each(function()&#123;$(this).click()&#125;) Step 3 点击头像右侧的Following, 一直下拉到底部, 粘贴并执行脚本, 等一会就全部UnFollow了. 不要在当前页面重复执行哦. 点一次是取消, 再点一次可就是又关注了.1$(&quot;.following .js-follow-btn&quot;).click()]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Twitter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm的内存划分(1.7+)笔记]]></title>
    <url>%2Fpost%2F14515.html</url>
    <content type="text"><![CDATA[程序计数器: 没有OOM, 线程私有, 线程间互不干扰, 用来指示线程执行指令地址的. Native方法没有计数器值. 虚拟机栈: 线程私有, 生命周期同线程, 方法在执行的时候会创建一个栈帧用来存局部变量, 动态链接, 方法出口等信息. 一个方法从调用到执行完毕, 对应着一个栈帧从入栈到出栈. 通常被称为”栈内存”. 当线程请求的栈深度大于虚拟机所允许的深度, 抛出StackOverflowError. 如果虚拟机栈可以动态扩展(Java可以动态扩展也可以固定长度), 在扩展时若无法申请到足够内存则抛出OutOfMemoryError. 本地方法栈: 作用类似虚拟机栈, 不过本地方法栈执行Native方法. 也会有StackOverflowError和OutOfMemoryError出现. 方法区: 线程共享, 存储类的信息、常量池、方法数据、方法代码(编译器编码后的)等.”java.lang.OutOfMemoryError: PermGen space “就是指的方法区. 堆: 内存最大, 线程共享, 在虚拟机启动时创建. 用作存放对象实例, 也是GC的主要区域. 细分为新生代和老年代. 永久带: 1.8之后永久带转换成了元空间(Metaspace), 且PermSize 和 MaxPermSize 会被忽略并给出警告. 在1.7中开始移除, 但未完全移除. 其中原因可能有: 字符串在永久带中不利于GC, 容易出现性能问题和内存溢出. 类和方法的信息比较难确定大小, 所以永久带不好指定大小, 大了老年代溢出, 小了永久带溢出 元空间: 元空间内存储的类元数据的生命周期等于该类的类加载器生命周期, 不再单独回收某各类, 且对象的位置是固定的, 当类加载器不再存活, 被gc声明死亡后, 该类加载器对应的空间就会被回收. 元空间使用-XX：MinMetaspaceFreeRatio和-XX：MaxMetaspaceFreeRatio进行调节. 常量池: 方法区的一部分. 用于存放编译期和运行时生成的各种字面量和符号引用. 比如String类的intern方法 直接内存: 也就是堆外内存, NIO可以通过Native函数直接分配, 通过在堆中的DirectByteBuffer作为引用进行操作. 注意内存泄漏导致的OOM.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机获取图片的API收集]]></title>
    <url>%2Fpost%2F18256.html</url>
    <content type="text"><![CDATA[食用方法可以是img标签嵌入在网页中, 也可以在iwall.app里面设置你的桌面背景. 速度: ★★★★★ 功能: 返回Bing的随机图片 地址: https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture 速度: ★★★★★ 功能: 返回随机图片, 需指定分辨率, 如果指定的分辨率没有找到图片则返回空页面 地址: http://lorempixel.com/1600/900 速度: ★★★★☆ 功能: 来自github的项目https://github.com/xCss/bing 地址: https://bing.ioliu.cn/v1/rand (返回随机图片) ​ https://bing.ioliu.cn/v1/rand?w=1920&amp;h=1200 (指定大小) 12345678910111213141516171819/** * 已知分辨率 */resolutions: [ &apos;1920x1200&apos;, &apos;1920x1080&apos;, &apos;1366x768&apos;, &apos;1280x768&apos;, &apos;1024x768&apos;, &apos;800x600&apos;, &apos;800x480&apos;, &apos;768x1280&apos;, &apos;720x1280&apos;, &apos;640x480&apos;, &apos;480x800&apos;, &apos;400x240&apos;, &apos;320x240&apos;, &apos;240x320&apos;] 速度: ★★☆☆☆ 功能: 返回指定分辨率的随机图片, (加载最慢, 可能是因为服务器在国外) 地址: https://unsplash.it/1600/900?random 速度: ★★★★★ 功能: 返回随机的二次元图片, 国人之作, 发现地址: https://www.dujin.org/12142.html/amp 地址: https://api.xjdog.cn/Get-Image 速度: ★★★★★★ 功能: 返回随机Bing图片, 其中数字为分辨率, 例如 1366x768 -&gt; 1366, 1920x1080 -&gt; 1920 地址: https://api.dujin.org/bing/1366.php ​ 还有其他好用的API吗? 请在下放留下您的评论. 非常感谢!]]></content>
      <categories>
        <category>Image</category>
      </categories>
      <tags>
        <tag>img</tag>
        <tag>随机图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 Files和Paths 踩坑记录]]></title>
    <url>%2Fpost%2F23178.html</url>
    <content type="text"><![CDATA[咩.java7引进的java.nio.file包的Files和Paths还有其他工具类, 以代替File和各类Stream进行文件的IO操作. 好用是好用, 就是总有些细节让人蛋疼. 逐步更新中. 1. Files.createFile(path)或者Files.write()时抛出NoSuchFileException这两个方法在path含有路径时, 会直接去创建目标文件, 所以当路径中间有文件夹未被创建, 就抛出此异常. 1234// 加个判断就OK了Path path = Paths.get(dir);if (!Files.exists(path)) Files.createDirectories(path); 2. java.nio.charset.MalformedInputException: Input length = 11234// Files读取文件的默认编码是UTF-8public static Stream&lt;String&gt; lines(Path path) throws IOException &#123; return lines(path, StandardCharsets.UTF_8);&#125; 通常该异常是因为读取的文件编码不是utf-8引起的. 但我这次引起是因为mac创建的DS_Store文件, 该文件是mac用于贮存目录自定义属性, 例如文件夹们的图标位置或者背景色之类. 1234// 特意的加了文件名的判断. 避免错误的解析DS_Store文件.List&lt;Path&gt; fileList = Files.list(Paths.get(basePath)) .filter(path -&gt; !Files.isDirectory(path) &amp;&amp; !path.getFileName().toString().contains("DS_Store")) .collect(Collectors.toList());]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Files</tag>
        <tag>Paths</tag>
        <tag>NoSuchFileException</tag>
        <tag>MalformedInputException</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java导出dbf格式文件]]></title>
    <url>%2Fpost%2F46831.html</url>
    <content type="text"><![CDATA[dbf文件相关属性 DBFField.FIELD_TYPE_D 表示Date型 DBFField.FIELD_TYPE_L 表示布尔型 DBFField.FIELD_TYPE_N 表示数字 DBFField.FIELD_TYPE_C 表示字符串 DBFField.FIELD_TYPE_F 表示浮点型 DBFField.FIELD_TYPE_M 不晓得,欢迎补充 jar: https://pan.baidu.com/s/1J9vuPItrNlMs2x5MYVURsw 1. 定义DBF文件字段12345678910111213141516// 字段数组DBFField[] fields = new DBFField[列的个数];// 表头---数组String[] strutName = new String[列的个数]// 数据类型 -- 数组byte[] strutType = new byte[列的个数];// 设置名称fields[i].setName(strutName[i]);// 设置类型fields[i].setDataType(strutType[i]);// 根据数据类型和数据本身指定数据长度(日期类型一般不指定长度)fields[i].setFieldLength(15);// 如果数据类型是浮点型 需要制定小数点位数 2 --&gt; 0.00fields[i].setDecimalCount(2);// 如果数据类型是数值型不需要指定小数点位数, 会直接四舍五入 2. 逐条的写入记录 123Object[] rowData = new Object[列的个数];// 如果要插入的数据是数字 但是为null 需要指定0 不可以使用空字符串和nullrowData[z] = Double.parseDouble("0"); 3. 输出文件 12345678910// 定义输出流，并关联的一个文件// 这里需要注意的是,输出dbf是在已经存在的dbf文件中覆盖写入数据.所以在定义输出流的时候必须要指定一个存在dbf文件的路径并且指定名称.File rootFile = new File(Play.applicationPath, "/public/download");OutputStream fos = new FileOutputStream(rootFile.getPath()+文件名称.dbf);// 定义 DBF输出对象DBFWriter writer = new DBFWriter();writer.setFields(fields);writer.addRecord(rowData);writer.write(fos); 4. 代码参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 以下为系统中的代码, 仅供参考public boolean outputDBF(List&lt;PropertyFilter&gt; propertyFilterList) &#123; OutputStream fos = null; try &#123; List&lt;Object&gt; query = departinvoicesManagerDao.queryDBFinfo(propertyFilterList); String dbfName = new String("结算单管理.dbf"); StringBuffer sb = new StringBuffer(); String[] strutName = sb.append("JSRS,JSRQ,JSDH,GSDM,DWDM,DWMC,CH,JPSR,JSSR,XLF,TPF,CC,FJF,GLQF,RYFJF") .toString().split(","); byte[] strutType = new byte[15]; strutType[0] = DBFField.FIELD_TYPE_N;// JSRS strutType[1] = DBFField.FIELD_TYPE_D;// JSRQ strutType[2] = DBFField.FIELD_TYPE_C;// JSDH strutType[3] = DBFField.FIELD_TYPE_C;// GSDM strutType[4] = DBFField.FIELD_TYPE_C;// DWDM strutType[5] = DBFField.FIELD_TYPE_C;// DWMC strutType[6] = DBFField.FIELD_TYPE_C;// CH strutType[7] = DBFField.FIELD_TYPE_F;// JPSR strutType[8] = DBFField.FIELD_TYPE_F;// JSSR strutType[9] = DBFField.FIELD_TYPE_F;// XLF strutType[10] = DBFField.FIELD_TYPE_F;// TPF strutType[11] = DBFField.FIELD_TYPE_C;// CC strutType[12] = DBFField.FIELD_TYPE_F;// FJF strutType[13] = DBFField.FIELD_TYPE_F;// GLQF strutType[14] = DBFField.FIELD_TYPE_F;// RYFJF // 定义DBF文件字段 DBFField[] fields = new DBFField[15]; for (int i = 0; i &lt;= 14; i++) &#123; fields[i] = new DBFField(); fields[i].setName(strutName[i]); fields[i].setDataType(strutType[i]); // Date类型不能设置字段长度，这里没有处理其它没有字段长度的类型 if (strutType[i] == DBFField.FIELD_TYPE_C) &#123; fields[i].setFieldLength(20); &#125; else if (strutType[i] == DBFField.FIELD_TYPE_N) &#123; fields[i].setFieldLength(15); &#125; else if (strutType[i] == DBFField.FIELD_TYPE_F) &#123; fields[i].setFieldLength(15); fields[i].setDecimalCount(2); &#125; &#125; DBFWriter writer = new DBFWriter(); writer.setFields(fields); // 一条条的写入记录 for (int j = 0; j &lt; query.size(); j++) &#123; Object[] object = (Object[]) query.get(j); Object[] rowData = new Object[15]; for (int z = 0; z &lt; 15; z++) &#123; if (fields[z].getDataType() == DBFField.FIELD_TYPE_N || fields[z].getDataType() == DBFField.FIELD_TYPE_F) &#123; if (object[z] != null) &#123; rowData[z] = Double.parseDouble(object[z].toString()); &#125; else &#123; rowData[z] = Double.parseDouble("0"); &#125; &#125; else &#123; rowData[z] = object[z]; &#125; &#125; writer.addRecord(rowData); &#125; // 定义输出流，并关联的一个文件 File rootFile = new File(Play.applicationPath, "/public/download"); fos = new FileOutputStream(rootFile.getPath() + "\\" + dbfName); // 写入数据 writer.write(fos); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fos.close(); &#125; catch (Exception e) &#123; &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dbf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的几种状态(笔记)]]></title>
    <url>%2Fpost%2F56550.html</url>
    <content type="text"><![CDATA[在TCP层, 有个FLAGS字段, 这个字段有以下几个标识: SYN : 建立连接, FIN : 关闭连接, ACK : 响应, PSH : 有未分片的DATA数据传输, RST : 连接重置. 其中, ACK是可能与SYN, FIN等同时使用的. 比如SYN和ACK可能同时为1, 它表示的就是建立连接之后的响应, 如果只是单个的一个SYN, 它表示的只是建立连接, TCP的几次握手就是通过这样的ACK表现出来的.但SYN与FIN是不会同时为1的, 因为前者表示的是建立连接, 而后者表示的是断开连接. RST一般是在FIN之后才会出现为1的情况, 表示的是连接重置. 一般地, 当出现FIN包或RST包时, 我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时, 我们认为客户端与服务器建立了一个连接. PSH为1的情况, 一般只出现在 DATA内容不为0的包中, 也就是说PSH为1表示的是有真正的TCP数据包内容被传递.TCP的连接建立和连接关闭, 都是通过请求－响应的模式完成的. 概念补充-TCP三次握手:TCP(Transmission Control Protocol)传输控制协议是主机对主机层的传输控制协议, 提供可靠的连接服务, 采用三次握手确认建立一个连接. 位码即tcp标志位, 有6种标示: SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急) 其他如: Sequence number(顺序号码), Acknowledge number(确认号码) 等. 第一次握手：主机A发送位码为syn＝1, 随机产生seq number=1234567的数据包到服务器, 主机B由SYN=1知道, A要求建立联机; 第二次握手: 主机B收到请求后要确认联机信息, 向A发送ack number=(主机A的seq+1), syn=1, ack=1, 随机产生seq=7654321的包; 第三次握手: 主机A收到后检查ack number是否正确, 即第一次发送的seq number+1, 以及位码ack是否为1, 若正确, 主机A会再发送ack number=(主机B的seq+1), ack=1, 主机B收到后确认seq值与ack=1则连接建立成功. 完成三次握手, 主机A与主机B开始传送数据. 在TCP/IP协议中, TCP协议提供可靠的连接服务, 采用三次握手建立一个连接. 第一次握手: 建立连接时, 客户端发送syn包(syn=j)到服务器, 并进入SYN_SEND状态, 等待服务器确认; 第二次握手: 服务器收到syn包, 必须确认客户的SYN（ack=j+1）, 同时自己也发送一个SYN包（syn=k）, 即SYN+ACK包, 此时服务器进入SYN_RECV状态； 第三次握手: 客户端收到服务器的SYN＋ACK包, 向服务器发送确认包ACK(ack=k+1), 此包发送完毕, 客户端和服务器进入ESTABLISHED状态, 完成三次握手. 完成三次握手, 客户端与服务器开始传送数据. 摘自中国云安网, 原文链接:http://www.yunsec.net/a/school/wlcs/agreement/2012/0317/10262.html]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在VPS上搭建ss或v2ray]]></title>
    <url>%2Fpost%2F52793.html</url>
    <content type="text"><![CDATA[ss当初购买的是vultr的服务器, 系统为CentOs7 X64v2ray是用的Google Cloud, 俗称GCP, 系统同为CentOs7 X64 ss一般linux都会带python, 就不写怎么安装了. 12345678910111213141516171819202122232425# 使用pip安装shadowsockspip install shadowsocks# 创建并编辑配置mkdir /etc/shadowsocksvim /etc/shadowsocks/config.json# 添加配置(多端口)&#123; "server":"VPS的外网IP地址", "local_address":"127.0.0.1", # 本地代理地址, 默认就好 "local_port":1080, # 本地代理端口 "port_password": &#123; "端口1":"密码1", "端口2":"密码2", "端口3":"密码3" &#125;, "timeout":300, # 超时时间 "method":"aes-256-cfb", # 加密算法 "fast_open":false&#125;# 启动方式ssserver -c /etc/shadowsocks/config.json -d start 后台启动ssserver -c /etc/shadowsocks/config.json -d stop 后台停止 v2ray官网地址: https://www.v2ray.com12# 执行shell脚本即可, 一键安装bash &lt;(curl -L -s https://install.direct/go.sh) 此脚本会自动安装以下文件: /usr/bin/v2ray/v2ray：V2Ray 程序； /usr/bin/v2ray/v2ctl：V2Ray 工具； /etc/v2ray/config.json：配置文件； /usr/bin/v2ray/geoip.dat：IP 数据文件 /usr/bin/v2ray/geosite.dat：域名数据文件 此脚本会配置自动运行脚本. 自动运行脚本会在系统重启之后, 自动运行 V2Ray.目前自动运行脚本只支持带有 Systemd 的系统, 以及 Debian / Ubuntu 全系列. 运行脚本位于系统的以下位置: /etc/systemd/system/v2ray.service: Systemd /etc/init.d/v2ray: SysV 脚本运行完成后，你需要： 编辑 /etc/v2ray/config.json 文件来配置你需要的代理方式； 运行 service v2ray start 来启动 V2Ray 进程； 之后可以使用 service v2ray start|stop|status|reload|restart|force-reload 控制 V2Ray 的运行。 TCP加速Google BBR是一种新兴的TCP单边加速方案, 建议开启BBR加速算法123wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 其他注意事项 如果用的是像阿里云, Google Cloud, 腾讯云, AWS等云平台, 记得开放端口. 如果你的镜像里没有pip, 但是有python, 那就装一个. 12345# 如果连wget都没有, 像Google Cloud提供的CentOS就比较干净.yum install wgetwget https://bootstrap.pypa.io/get-pip.pypython get-pip.py# 如果连python都没有, 百度吧 端口个数看使用情况定, 通常来说几个人用就开几个端口.]]></content>
      <categories>
        <category>梯子</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>v2ray</tag>
      </tags>
  </entry>
</search>
