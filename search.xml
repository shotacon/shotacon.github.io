<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jvm的内存划分(1.7+)笔记]]></title>
    <url>%2Fpost%2F14515.html</url>
    <content type="text"><![CDATA[程序计数器: 没有OOM, 线程私有, 线程间互不干扰, 用来指示线程执行指令地址的. Native方法没有计数器值. 虚拟机栈: 线程私有, 生命周期同线程, 方法在执行的时候会创建一个栈帧用来存局部变量, 动态链接, 方法出口等信息. 一个方法从调用到执行完毕, 对应着一个栈帧从入栈到出栈. 通常被称为”栈内存”. 当线程请求的栈深度大于虚拟机所允许的深度, 抛出StackOverflowError. 如果虚拟机栈可以动态扩展(Java可以动态扩展也可以固定长度), 在扩展时若无法申请到足够内存则抛出OutOfMemoryError. 本地方法栈: 作用类似虚拟机栈, 不过本地方法栈执行Native方法. 也会有StackOverflowError和OutOfMemoryError出现. 方法区: 线程共享, 存储类的信息、常量池、方法数据、方法代码(编译器编码后的)等.”java.lang.OutOfMemoryError: PermGen space “就是指的方法区. 堆: 内存最大, 线程共享, 在虚拟机启动时创建. 用作存放对象实例, 也是GC的主要区域. 细分为新生代和老年代. 永久带: 1.8之后永久带转换成了元空间(Metaspace), 且PermSize 和 MaxPermSize 会被忽略并给出警告. 在1.7中开始移除, 但未完全移除. 其中原因可能有: 字符串在永久带中不利于GC, 容易出现性能问题和内存溢出. 类和方法的信息比较难确定大小, 所以永久带不好指定大小, 大了老年代溢出, 小了永久带溢出 元空间: 元空间内存储的类元数据的生命周期等于该类的类加载器生命周期, 不再单独回收某各类, 且对象的位置是固定的, 当类加载器不再存活, 被gc声明死亡后, 该类加载器对应的空间就会被回收. 元空间使用-XX：MinMetaspaceFreeRatio和-XX：MaxMetaspaceFreeRatio进行调节. 常量池: 方法区的一部分. 用于存放编译期和运行时生成的各种字面量和符号引用. 比如String类的intern方法 直接内存: 也就是堆外内存, NIO可以通过Native函数直接分配, 通过在堆中的DirectByteBuffer作为引用进行操作. 注意内存泄漏导致的OOM.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机获取图片的API收集]]></title>
    <url>%2Fpost%2F18256.html</url>
    <content type="text"><![CDATA[食用方法可以是img标签嵌入在网页中, 也可以在iwall.app里面设置你的桌面背景. 速度: ★★★★★ 功能: 返回Bing的随机图片 地址: https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture 速度: ★★★★★ 功能: 返回随机图片, 需指定分辨率, 如果指定的分辨率没有找到图片则返回空页面 地址: http://lorempixel.com/1600/900 速度: ★★★★☆ 功能: 来自github的项目https://github.com/xCss/bing 地址: https://bing.ioliu.cn/v1/rand (返回随机图片) ​ https://bing.ioliu.cn/v1/rand?w=1920&amp;h=1200 (指定大小) 12345678910111213141516171819/** * 已知分辨率 */resolutions: [ &apos;1920x1200&apos;, &apos;1920x1080&apos;, &apos;1366x768&apos;, &apos;1280x768&apos;, &apos;1024x768&apos;, &apos;800x600&apos;, &apos;800x480&apos;, &apos;768x1280&apos;, &apos;720x1280&apos;, &apos;640x480&apos;, &apos;480x800&apos;, &apos;400x240&apos;, &apos;320x240&apos;, &apos;240x320&apos;] 速度: ★★☆☆☆ 功能: 返回指定分辨率的随机图片, (加载最慢, 可能是因为服务器在国外) 地址: https://unsplash.it/1600/900?random 速度: ★★★★★ 功能: 返回随机的二次元图片, 国人之作, 发现地址: https://www.dujin.org/12142.html/amp 地址: https://api.xjdog.cn/Get-Image 速度: ★★★★★★ 功能: 返回随机Bing图片, 其中数字为分辨率, 例如 1366x768 -&gt; 1366, 1920x1080 -&gt; 1920 地址: https://api.dujin.org/bing/1366.php ​ 还有其他好用的API吗? 请在下放留下您的评论. 非常感谢!]]></content>
      <categories>
        <category>Image</category>
      </categories>
      <tags>
        <tag>img</tag>
        <tag>随机图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 Files和Paths 踩坑记录]]></title>
    <url>%2Fpost%2F23178.html</url>
    <content type="text"><![CDATA[咩.java7引进的java.nio.file包的Files和Paths还有其他工具类, 以代替File和各类Stream进行文件的IO操作. 好用是好用, 就是总有些细节让人蛋疼. 逐步更新中. 1. Files.createFile(path)或者Files.write()时抛出NoSuchFileException这两个方法在path含有路径时, 会直接去创建目标文件, 所以当路径中间有文件夹未被创建, 就抛出此异常. 1234// 加个判断就OK了Path path = Paths.get(dir);if (!Files.exists(path)) Files.createDirectories(path); 2. java.nio.charset.MalformedInputException: Input length = 11234// Files读取文件的默认编码是UTF-8public static Stream&lt;String&gt; lines(Path path) throws IOException &#123; return lines(path, StandardCharsets.UTF_8);&#125; 通常该异常是因为读取的文件编码不是utf-8引起的. 但我这次引起是因为mac创建的DS_Store文件, 该文件是mac用于贮存目录自定义属性, 例如文件夹们的图标位置或者背景色之类. 1234// 特意的加了文件名的判断. 避免错误的解析DS_Store文件.List&lt;Path&gt; fileList = Files.list(Paths.get(basePath)) .filter(path -&gt; !Files.isDirectory(path) &amp;&amp; !path.getFileName().toString().contains("DS_Store")) .collect(Collectors.toList());]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Files</tag>
        <tag>Paths</tag>
        <tag>NoSuchFileException</tag>
        <tag>MalformedInputException</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java导出dbf格式文件]]></title>
    <url>%2Fpost%2F46831.html</url>
    <content type="text"><![CDATA[dbf文件相关属性 DBFField.FIELD_TYPE_D 表示Date型 DBFField.FIELD_TYPE_L 表示布尔型 DBFField.FIELD_TYPE_N 表示数字 DBFField.FIELD_TYPE_C 表示字符串 DBFField.FIELD_TYPE_F 表示浮点型 DBFField.FIELD_TYPE_M 不晓得,欢迎补充 jar: https://pan.baidu.com/s/1J9vuPItrNlMs2x5MYVURsw 1. 定义DBF文件字段12345678910111213141516// 字段数组DBFField[] fields = new DBFField[列的个数];// 表头---数组String[] strutName = new String[列的个数]// 数据类型 -- 数组byte[] strutType = new byte[列的个数];// 设置名称fields[i].setName(strutName[i]);// 设置类型fields[i].setDataType(strutType[i]);// 根据数据类型和数据本身指定数据长度(日期类型一般不指定长度)fields[i].setFieldLength(15);// 如果数据类型是浮点型 需要制定小数点位数 2 --&gt; 0.00fields[i].setDecimalCount(2);// 如果数据类型是数值型不需要指定小数点位数, 会直接四舍五入 2. 逐条的写入记录 123Object[] rowData = new Object[列的个数];// 如果要插入的数据是数字 但是为null 需要指定0 不可以使用空字符串和nullrowData[z] = Double.parseDouble("0"); 3. 输出文件 12345678910// 定义输出流，并关联的一个文件// 这里需要注意的是,输出dbf是在已经存在的dbf文件中覆盖写入数据.所以在定义输出流的时候必须要指定一个存在dbf文件的路径并且指定名称.File rootFile = new File(Play.applicationPath, "/public/download");OutputStream fos = new FileOutputStream(rootFile.getPath()+文件名称.dbf);// 定义 DBF输出对象DBFWriter writer = new DBFWriter();writer.setFields(fields);writer.addRecord(rowData);writer.write(fos); 4. 代码参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 以下为系统中的代码, 仅供参考public boolean outputDBF(List&lt;PropertyFilter&gt; propertyFilterList) &#123; OutputStream fos = null; try &#123; List&lt;Object&gt; query = departinvoicesManagerDao.queryDBFinfo(propertyFilterList); String dbfName = new String("结算单管理.dbf"); StringBuffer sb = new StringBuffer(); String[] strutName = sb.append("JSRS,JSRQ,JSDH,GSDM,DWDM,DWMC,CH,JPSR,JSSR,XLF,TPF,CC,FJF,GLQF,RYFJF") .toString().split(","); byte[] strutType = new byte[15]; strutType[0] = DBFField.FIELD_TYPE_N;// JSRS strutType[1] = DBFField.FIELD_TYPE_D;// JSRQ strutType[2] = DBFField.FIELD_TYPE_C;// JSDH strutType[3] = DBFField.FIELD_TYPE_C;// GSDM strutType[4] = DBFField.FIELD_TYPE_C;// DWDM strutType[5] = DBFField.FIELD_TYPE_C;// DWMC strutType[6] = DBFField.FIELD_TYPE_C;// CH strutType[7] = DBFField.FIELD_TYPE_F;// JPSR strutType[8] = DBFField.FIELD_TYPE_F;// JSSR strutType[9] = DBFField.FIELD_TYPE_F;// XLF strutType[10] = DBFField.FIELD_TYPE_F;// TPF strutType[11] = DBFField.FIELD_TYPE_C;// CC strutType[12] = DBFField.FIELD_TYPE_F;// FJF strutType[13] = DBFField.FIELD_TYPE_F;// GLQF strutType[14] = DBFField.FIELD_TYPE_F;// RYFJF // 定义DBF文件字段 DBFField[] fields = new DBFField[15]; for (int i = 0; i &lt;= 14; i++) &#123; fields[i] = new DBFField(); fields[i].setName(strutName[i]); fields[i].setDataType(strutType[i]); // Date类型不能设置字段长度，这里没有处理其它没有字段长度的类型 if (strutType[i] == DBFField.FIELD_TYPE_C) &#123; fields[i].setFieldLength(20); &#125; else if (strutType[i] == DBFField.FIELD_TYPE_N) &#123; fields[i].setFieldLength(15); &#125; else if (strutType[i] == DBFField.FIELD_TYPE_F) &#123; fields[i].setFieldLength(15); fields[i].setDecimalCount(2); &#125; &#125; DBFWriter writer = new DBFWriter(); writer.setFields(fields); // 一条条的写入记录 for (int j = 0; j &lt; query.size(); j++) &#123; Object[] object = (Object[]) query.get(j); Object[] rowData = new Object[15]; for (int z = 0; z &lt; 15; z++) &#123; if (fields[z].getDataType() == DBFField.FIELD_TYPE_N || fields[z].getDataType() == DBFField.FIELD_TYPE_F) &#123; if (object[z] != null) &#123; rowData[z] = Double.parseDouble(object[z].toString()); &#125; else &#123; rowData[z] = Double.parseDouble("0"); &#125; &#125; else &#123; rowData[z] = object[z]; &#125; &#125; writer.addRecord(rowData); &#125; // 定义输出流，并关联的一个文件 File rootFile = new File(Play.applicationPath, "/public/download"); fos = new FileOutputStream(rootFile.getPath() + "\\" + dbfName); // 写入数据 writer.write(fos); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fos.close(); &#125; catch (Exception e) &#123; &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dbf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的几种状态(笔记)]]></title>
    <url>%2Fpost%2F56550.html</url>
    <content type="text"><![CDATA[在TCP层, 有个FLAGS字段, 这个字段有以下几个标识: SYN : 建立连接, FIN : 关闭连接, ACK : 响应, PSH : 有未分片的DATA数据传输, RST : 连接重置. 其中, ACK是可能与SYN, FIN等同时使用的. 比如SYN和ACK可能同时为1, 它表示的就是建立连接之后的响应, 如果只是单个的一个SYN, 它表示的只是建立连接, TCP的几次握手就是通过这样的ACK表现出来的.但SYN与FIN是不会同时为1的, 因为前者表示的是建立连接, 而后者表示的是断开连接. RST一般是在FIN之后才会出现为1的情况, 表示的是连接重置. 一般地, 当出现FIN包或RST包时, 我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时, 我们认为客户端与服务器建立了一个连接. PSH为1的情况, 一般只出现在 DATA内容不为0的包中, 也就是说PSH为1表示的是有真正的TCP数据包内容被传递.TCP的连接建立和连接关闭, 都是通过请求－响应的模式完成的. 概念补充-TCP三次握手:TCP(Transmission Control Protocol)传输控制协议是主机对主机层的传输控制协议, 提供可靠的连接服务, 采用三次握手确认建立一个连接. 位码即tcp标志位, 有6种标示: SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急) 其他如: Sequence number(顺序号码), Acknowledge number(确认号码) 等. 第一次握手：主机A发送位码为syn＝1, 随机产生seq number=1234567的数据包到服务器, 主机B由SYN=1知道, A要求建立联机; 第二次握手: 主机B收到请求后要确认联机信息, 向A发送ack number=(主机A的seq+1), syn=1, ack=1, 随机产生seq=7654321的包; 第三次握手: 主机A收到后检查ack number是否正确, 即第一次发送的seq number+1, 以及位码ack是否为1, 若正确, 主机A会再发送ack number=(主机B的seq+1), ack=1, 主机B收到后确认seq值与ack=1则连接建立成功. 完成三次握手, 主机A与主机B开始传送数据. 在TCP/IP协议中, TCP协议提供可靠的连接服务, 采用三次握手建立一个连接. 第一次握手: 建立连接时, 客户端发送syn包(syn=j)到服务器, 并进入SYN_SEND状态, 等待服务器确认; 第二次握手: 服务器收到syn包, 必须确认客户的SYN（ack=j+1）, 同时自己也发送一个SYN包（syn=k）, 即SYN+ACK包, 此时服务器进入SYN_RECV状态； 第三次握手: 客户端收到服务器的SYN＋ACK包, 向服务器发送确认包ACK(ack=k+1), 此包发送完毕, 客户端和服务器进入ESTABLISHED状态, 完成三次握手. 完成三次握手, 客户端与服务器开始传送数据. 摘自中国云安网, 原文链接:http://www.yunsec.net/a/school/wlcs/agreement/2012/0317/10262.html]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在VPS上搭建ss或v2ray]]></title>
    <url>%2Fpost%2F52793.html</url>
    <content type="text"><![CDATA[ss当初购买的是vultr的服务器, 系统为CentOs7 X64v2ray是用的Google Cloud, 俗称GCP, 系统同为CentOs7 X64 ss一般linux都会带python, 就不写怎么安装了. 12345678910111213141516171819202122232425# 使用pip安装shadowsockspip install shadowsocks# 创建并编辑配置mkdir /etc/shadowsocksvim /etc/shadowsocks/config.json# 添加配置(多端口)&#123; "server":"VPS的外网IP地址", "local_address":"127.0.0.1", # 本地代理地址, 默认就好 "local_port":1080, # 本地代理端口 "port_password": &#123; "端口1":"密码1", "端口2":"密码2", "端口3":"密码3" &#125;, "timeout":300, # 超时时间 "method":"aes-256-cfb", # 加密算法 "fast_open":false&#125;# 启动方式ssserver -c /etc/shadowsocks/config.json -d start 后台启动ssserver -c /etc/shadowsocks/config.json -d stop 后台停止 v2ray官网地址: https://www.v2ray.com12# 执行shell脚本即可, 一键安装bash &lt;(curl -L -s https://install.direct/go.sh) 此脚本会自动安装以下文件: /usr/bin/v2ray/v2ray：V2Ray 程序； /usr/bin/v2ray/v2ctl：V2Ray 工具； /etc/v2ray/config.json：配置文件； /usr/bin/v2ray/geoip.dat：IP 数据文件 /usr/bin/v2ray/geosite.dat：域名数据文件 此脚本会配置自动运行脚本. 自动运行脚本会在系统重启之后, 自动运行 V2Ray.目前自动运行脚本只支持带有 Systemd 的系统, 以及 Debian / Ubuntu 全系列. 运行脚本位于系统的以下位置: /etc/systemd/system/v2ray.service: Systemd /etc/init.d/v2ray: SysV 脚本运行完成后，你需要： 编辑 /etc/v2ray/config.json 文件来配置你需要的代理方式； 运行 service v2ray start 来启动 V2Ray 进程； 之后可以使用 service v2ray start|stop|status|reload|restart|force-reload 控制 V2Ray 的运行。 TCP加速Google BBR是一种新兴的TCP单边加速方案, 建议开启BBR加速算法123wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 其他注意事项 如果用的是像阿里云, Google Cloud, 腾讯云, AWS等云平台, 记得开放端口. 如果你的镜像里没有pip, 但是有python, 那就装一个. 12345# 如果连wget都没有, 像Google Cloud提供的CentOS就比较干净.yum install wgetwget https://bootstrap.pypa.io/get-pip.pypython get-pip.py# 如果连python都没有, 百度吧 端口个数看使用情况定, 通常来说几个人用就开几个端口.]]></content>
      <categories>
        <category>梯子</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>v2ray</tag>
      </tags>
  </entry>
</search>
