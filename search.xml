<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java8 Files和Paths 踩坑记录]]></title>
    <url>%2F2018%2F12%2F09%2FJava8%20Files%E5%92%8CPaths%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[咩.java7引进的java.nio.file包的Files和Paths还有其他工具类, 以代替File和各类Stream进行文件的IO操作. 好用是好用, 就是总有些细节让人蛋疼. 逐步更新中. 1. Files.createFile(path)或者Files.write()时抛出NoSuchFileException这两个方法在path含有路径时, 会直接去创建目标文件, 所以当路径中间有文件夹未被创建, 就抛出此异常. 1234// 加个判断就OK了Path path = Paths.get(dir);if (!Files.exists(path)) Files.createDirectories(path); 2. java.nio.charset.MalformedInputException: Input length = 11234// Files读取文件的默认编码是UTF-8public static Stream&lt;String&gt; lines(Path path) throws IOException &#123; return lines(path, StandardCharsets.UTF_8);&#125; 通常该异常是因为读取的文件编码不是utf-8引起的. 但我这次引起是因为mac创建的DS_Store文件, 该文件是mac用于贮存目录自定义属性, 例如文件夹们的图标位置或者背景色之类. 1234// 特意的加了文件名的判断. 避免错误的解析DS_Store文件.List&lt;Path&gt; fileList = Files.list(Paths.get(basePath)) .filter(path -&gt; !Files.isDirectory(path) &amp;&amp; !path.getFileName().toString().contains("DS_Store")) .collect(Collectors.toList());]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Files</tag>
        <tag>Paths</tag>
        <tag>NoSuchFileException</tag>
        <tag>MalformedInputException</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java导出dbf格式文件]]></title>
    <url>%2F2018%2F11%2F23%2Fjava%E5%AF%BC%E5%87%BAdbf%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[dbf文件相关属性 DBFField.FIELD_TYPE_D 表示Date型 DBFField.FIELD_TYPE_L 表示布尔型 DBFField.FIELD_TYPE_N 表示数字 DBFField.FIELD_TYPE_C 表示字符串 DBFField.FIELD_TYPE_F 表示浮点型 DBFField.FIELD_TYPE_M 不晓得,欢迎补充 jar: https://pan.baidu.com/s/1J9vuPItrNlMs2x5MYVURsw 1. 定义DBF文件字段12345678910111213141516// 字段数组DBFField[] fields = new DBFField[列的个数];// 表头---数组String[] strutName = new String[列的个数]// 数据类型 -- 数组byte[] strutType = new byte[列的个数];// 设置名称fields[i].setName(strutName[i]);// 设置类型fields[i].setDataType(strutType[i]);// 根据数据类型和数据本身指定数据长度(日期类型一般不指定长度)fields[i].setFieldLength(15);// 如果数据类型是浮点型 需要制定小数点位数 2 --&gt; 0.00fields[i].setDecimalCount(2);// 如果数据类型是数值型不需要指定小数点位数, 会直接四舍五入 2. 逐条的写入记录 123Object[] rowData = new Object[列的个数];// 如果要插入的数据是数字 但是为null 需要指定0 不可以使用空字符串和nullrowData[z] = Double.parseDouble("0"); 3. 输出文件 12345678910// 定义输出流，并关联的一个文件// 这里需要注意的是,输出dbf是在已经存在的dbf文件中覆盖写入数据.所以在定义输出流的时候必须要指定一个存在dbf文件的路径并且指定名称.File rootFile = new File(Play.applicationPath, "/public/download");OutputStream fos = new FileOutputStream(rootFile.getPath()+文件名称.dbf);// 定义 DBF输出对象DBFWriter writer = new DBFWriter();writer.setFields(fields);writer.addRecord(rowData);writer.write(fos); 4. 代码参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 以下为系统中的代码, 仅供参考public boolean outputDBF(List&lt;PropertyFilter&gt; propertyFilterList) &#123; OutputStream fos = null; try &#123; List&lt;Object&gt; query = departinvoicesManagerDao.queryDBFinfo(propertyFilterList); String dbfName = new String("结算单管理.dbf"); StringBuffer sb = new StringBuffer(); String[] strutName = sb.append("JSRS,JSRQ,JSDH,GSDM,DWDM,DWMC,CH,JPSR,JSSR,XLF,TPF,CC,FJF,GLQF,RYFJF") .toString().split(","); byte[] strutType = new byte[15]; strutType[0] = DBFField.FIELD_TYPE_N;// JSRS strutType[1] = DBFField.FIELD_TYPE_D;// JSRQ strutType[2] = DBFField.FIELD_TYPE_C;// JSDH strutType[3] = DBFField.FIELD_TYPE_C;// GSDM strutType[4] = DBFField.FIELD_TYPE_C;// DWDM strutType[5] = DBFField.FIELD_TYPE_C;// DWMC strutType[6] = DBFField.FIELD_TYPE_C;// CH strutType[7] = DBFField.FIELD_TYPE_F;// JPSR strutType[8] = DBFField.FIELD_TYPE_F;// JSSR strutType[9] = DBFField.FIELD_TYPE_F;// XLF strutType[10] = DBFField.FIELD_TYPE_F;// TPF strutType[11] = DBFField.FIELD_TYPE_C;// CC strutType[12] = DBFField.FIELD_TYPE_F;// FJF strutType[13] = DBFField.FIELD_TYPE_F;// GLQF strutType[14] = DBFField.FIELD_TYPE_F;// RYFJF // 定义DBF文件字段 DBFField[] fields = new DBFField[15]; for (int i = 0; i &lt;= 14; i++) &#123; fields[i] = new DBFField(); fields[i].setName(strutName[i]); fields[i].setDataType(strutType[i]); // Date类型不能设置字段长度，这里没有处理其它没有字段长度的类型 if (strutType[i] == DBFField.FIELD_TYPE_C) &#123; fields[i].setFieldLength(20); &#125; else if (strutType[i] == DBFField.FIELD_TYPE_N) &#123; fields[i].setFieldLength(15); &#125; else if (strutType[i] == DBFField.FIELD_TYPE_F) &#123; fields[i].setFieldLength(15); fields[i].setDecimalCount(2); &#125; &#125; DBFWriter writer = new DBFWriter(); writer.setFields(fields); // 一条条的写入记录 for (int j = 0; j &lt; query.size(); j++) &#123; Object[] object = (Object[]) query.get(j); Object[] rowData = new Object[15]; for (int z = 0; z &lt; 15; z++) &#123; if (fields[z].getDataType() == DBFField.FIELD_TYPE_N || fields[z].getDataType() == DBFField.FIELD_TYPE_F) &#123; if (object[z] != null) &#123; rowData[z] = Double.parseDouble(object[z].toString()); &#125; else &#123; rowData[z] = Double.parseDouble("0"); &#125; &#125; else &#123; rowData[z] = object[z]; &#125; &#125; writer.addRecord(rowData); &#125; // 定义输出流，并关联的一个文件 File rootFile = new File(Play.applicationPath, "/public/download"); fos = new FileOutputStream(rootFile.getPath() + "\\" + dbfName); // 写入数据 writer.write(fos); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fos.close(); &#125; catch (Exception e) &#123; &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dbf</tag>
      </tags>
  </entry>
</search>
