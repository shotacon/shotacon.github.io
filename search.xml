<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Maven学习笔记]]></title>
    <url>%2Fpost%2Fbe02a930.html</url>
    <content type="text"><![CDATA[本文摘自https://www.jianshu.com/p/06f73e8cbf78仅做备份参考, 初学者请移步上面链接 一. settings.xml配置1. 配置文件位置settings.xml可以存在于两个位置. 安装目录的conf/settings.xml 用户目录的.m2/settings.xml 第一个配置为全局配置, 第二个为用户配置, 同时存在时会合并内容, 且用户配置会覆盖全局配置进行生效. 2. 标签2.1. localRepository该值表示构建系统本地仓库的路径。其默认值为${user.home}/.m2/repository 2.2. offline是否在离线模式下运行, 默认为false 2.3. proxies12345678910111213141516171819202122&lt;!--用来配置不同的代理，多代理profiles可以应对笔记本或移动设备的工作环境：通过简单的设置profile id就可以很容易的更换整个代理配置 --&gt;&lt;proxies&gt; &lt;!--代理元素包含配置代理时需要的信息 --&gt; &lt;proxy&gt; &lt;!--代理的唯一定义符，用来区分不同的代理元素。 --&gt; &lt;id&gt;myproxy&lt;/id&gt; &lt;!--该代理是否是激活的那个。true则激活代理。当我们声明了一组代理，而某个时候只需要激活一个代理的时候，该元素就可以派上用处 --&gt; &lt;active&gt;true&lt;/active&gt; &lt;!--代理的协议。 协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;protocol&gt;http://…&lt;/protocol&gt; &lt;!--代理的主机名。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;host&gt;proxy.somewhere.com&lt;/host&gt; &lt;!--代理的端口。协议://主机名:端口，分隔成离散的元素以方便配置。 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!--代理的用户名，用户名和密码表示代理服务器认证的登录名和密码。 --&gt; &lt;username&gt;proxyuser&lt;/username&gt; &lt;!--代理的密码，用户名和密码表示代理服务器认证的登录名和密码。 --&gt; &lt;password&gt;somepassword&lt;/password&gt; &lt;!--不该被代理的主机名列表。该列表的分隔符由代理服务器指定；例子中使用了竖线分隔符，使用逗号分隔也很常见。 --&gt; &lt;nonProxyHosts&gt;*.google.com|ibiblio.org&lt;/nonProxyHosts&gt; &lt;/proxy&gt;&lt;/proxies&gt; 2.4. servers12345678910111213141516171819202122232425&lt;!--配置服务端的一些设置。一些设置如安全证书不应该和pom.xml一起分发。这种类型的信息应该存在于构建服务器上的settings.xml文件中。 --&gt;&lt;servers&gt; &lt;!--服务器元素包含配置服务器时需要的信息 --&gt; &lt;server&gt; &lt;!--这是server的id（注意不是用户登陆的id），该id与distributionManagement中repository元素的id相匹配。 --&gt; &lt;id&gt;server001&lt;/id&gt; &lt;!--鉴权用户名。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt; &lt;username&gt;my_login&lt;/username&gt; &lt;!--鉴权密码 。鉴权用户名和鉴权密码表示服务器认证所需要的登录名和密码。 --&gt; &lt;password&gt;my_password&lt;/password&gt; &lt;!--鉴权时使用的私钥位置。和前两个元素类似，私钥位置和私钥密码指定了一个私钥的路径 （默认是/home/hudson/.ssh/id_dsa）以及如果需要的话，一个密语。 将来passphrase和password元素可能会被提取到外部，但目前它们必须在settings.xml文件以纯文本的形式声明 --&gt; &lt;privateKey&gt;$&#123;usr.home&#125;/.ssh/id_dsa&lt;/privateKey&gt; &lt;!--鉴权时使用的私钥密码。 --&gt; &lt;passphrase&gt;some_passphrase&lt;/passphrase&gt; &lt;!--文件被创建时的权限。如果在部署的时候会创建一个仓库文件或者目录，这时候就可以使用权限（permission）。 这两个元素合法的值是一个三位数字，其对应了unix文件系统的权限，如664，或者775。 --&gt; &lt;filePermissions&gt;664&lt;/filePermissions&gt; &lt;!--目录被创建时的权限。 --&gt; &lt;directoryPermissions&gt;775&lt;/directoryPermissions&gt; &lt;!--传输层额外的配置项 --&gt; &lt;configuration&gt;&lt;/configuration&gt; &lt;/server&gt;&lt;/servers&gt; 2.5. mirrors1234567891011121314&lt;!--为仓库列表配置的下载镜像列表。 --&gt;&lt;mirrors&gt; &lt;!--给定仓库的下载镜像。 --&gt; &lt;mirror&gt; &lt;!--该镜像的唯一标识符。id用来区分不同的mirror元素。 --&gt; &lt;id&gt;planetmirror.com&lt;/id&gt; &lt;!--镜像名称 --&gt; &lt;name&gt;PlanetMirror Australia&lt;/name&gt; &lt;!--该镜像的URL。构建系统会优先考虑使用该URL，而非使用默认的服务器URL。 --&gt; &lt;url&gt;http://downloads.planetmirror.com/pub/maven2&lt;/url&gt; &lt;!--被镜像的服务器的id。例如，如果我们要设置了一个Maven中央仓库（http://repo1.maven.org/maven2）的镜像，就需要将该元素设置成central。这必须和中央仓库的id central完全一致。 --&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 2.6. profiles123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;!--根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。 它包含了id，activation, repositories, pluginRepositories和 properties元素。 这里的profile元素只包含这五个子元素是因为这里只关心构建系统这个整体（这正是settings.xml文件的角色定位），而非单独的项目对象模型设置。 如果一个settings中的profile被激活，它的值会覆盖任何其它定义在POM中或者profile.xml中的带有相同id的profile。 --&gt;&lt;profiles&gt; &lt;!--根据环境参数来调整的构件的配置 --&gt; &lt;profile&gt; &lt;!--该配置的唯一标识符。 --&gt; &lt;id&gt;test&lt;/id&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。 如POM中的profile一样，profile的力量来自于它能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。 activation元素并不是激活profile的唯一方式。settings.xml文件中的activeProfile元素可以包含profile的id。 profile也可以通过在命令行，使用-P标记和逗号分隔的列表来显式的激活（如，-P test）。 --&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标识 --&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;!--activation有一个内建的java版本检测，如果检测到jdk版本与期待的一样，profile被激活。 --&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 'windows') --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。 如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。 另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--对应profile的扩展属性列表。Maven属性和Ant中的属性一样，可以用来存放一些值。这些值可以在POM中的任何地方使用标记$&#123;X&#125;来使用，这里X是指属性的名称。 属性有五种不同的形式，并且都能在settings.xml文件中访问。 1. env.X: 在一个变量前加上"env."的前缀，会返回一个shell环境变量。例如,"env.PATH"指代了$path环境变量（在Windows上是%PATH%）。 2. project.x：指代了POM中对应的元素值。 3. settings.x: 指代了settings.xml中对应元素的值。 4. Java System Properties: 所有可通过java.lang.System.getProperties()访问的属性都能在POM中使用该形式访问， 如/usr/lib/jvm/java-1.6.0-openjdk-1.6.0.0/jre。 5. x: 在&lt;properties/&gt;元素中，或者外部文件中设置，以$&#123;someVar&#125;的形式使用。 --&gt; &lt;properties&gt; &lt;!-- 如果这个profile被激活，那么属性$&#123;user.install&#125;就可以被访问了 --&gt; &lt;user.install&gt;usr/local/winner/jobs/maven-guide&lt;/user.install&gt; &lt;/properties&gt; &lt;!--远程仓库列表，它是Maven用来填充构建系统本地仓库所使用的一组远程项目。 --&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--远程仓库唯一标识 --&gt; &lt;id&gt;codehausSnapshots&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;Codehaus Snapshots&lt;/name&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是： always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy&gt;always&lt;/updatePolicy&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做: ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy&gt;warn&lt;/checksumPolicy&gt; &lt;/releases&gt; &lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。 例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://snapshots.maven.codehaus.org/maven2&lt;/url&gt; &lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。 Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表。仓库是两种主要构件的家。第一种构件被用作其它构件的依赖。这是中央仓库中存储的大部分构件类型。另外一种构件类型是插件。 Maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。pluginRepositories元素的结构和repositories元素的结构类似。 每个pluginRepository元素指定一个Maven可以用来寻找新插件的远程地址。 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 --&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。 任何在activeProfile中定义的profile id，不论环境设置如何，其对应的 profile都会被激活。 如果没有匹配的profile，则什么都不会发生。例如，env-test是一个activeProfile，则在pom.xml（或者profile.xml）中对应id的profile会被激活。 如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。 --&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;env-test&lt;/activeProfile&gt; &lt;/activeProfiles&gt; &lt;/profile&gt;&lt;/profiles&gt; 二. pom.xml1. 标准pom1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!-- 模型版本。maven2.0必须是这样写，现在是maven2唯一支持的版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.winner.trade，maven会将该项目打成的jar包放本地路径：/com/winner/trade --&gt; &lt;groupId&gt;com.winner.trade&lt;/groupId&gt; &lt;!-- 本项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt; &lt;artifactId&gt;trade-core&lt;/artifactId&gt; &lt;!-- 本项目目前所处的版本号 --&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包的机制，如pom, jar, maven-plugin, ejb, war, ear, rar, par，默认为jar --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 帮助定义构件输出的一些附属构件,附属构件与主构件对应，有时候需要加上classifier才能唯一的确定该构件 不能直接定义项目的classifer,因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成的 --&gt; &lt;classifier&gt;...&lt;/classifier&gt; &lt;!-- 定义本项目的依赖关系 --&gt; &lt;dependencies&gt; &lt;!-- 每个dependency都对应这一个jar包 --&gt; &lt;dependency&gt; &lt;!-- 一般情况下，maven是通过groupId、artifactId、version这三个元素值（俗称坐标）来检索该构件， 然后引入你的工程。如果别人想引用你现在开发的这个项目（前提是已开发完毕并发布到了远程仓库）， 就需要在他的pom文件中新建一个dependency节点，将本项目的groupId、artifactId、version写入， maven就会把你上传的jar包下载到他的本地 --&gt; &lt;groupId&gt;com.winner.trade&lt;/groupId&gt; &lt;artifactId&gt;trade-test&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- maven认为，程序对外部的依赖会随着程序的所处阶段和应用场景而变化，所以maven中的依赖关系有作用域(scope)的限制。 scope包含如下的取值：compile（编译范围）、provided（已提供范围）、runtime（运行时范围）、test（测试范围）、system（系统范围） --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!-- 设置指依赖是否可选，默认为false,即子项目默认都继承:为true,则子项目必需显示的引入，与dependencyManagement里定义的依赖类似 。 --&gt; &lt;optional&gt;false&lt;/optional&gt; &lt;!-- 屏蔽依赖关系。 比如项目中使用的libA依赖某个库的1.0版，libB依赖某个库的2.0版，现在想统一使用2.0版，就应该屏蔽掉对1.0版的依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 为pom定义一些常量，在pom中的其它地方可以直接引用 使用方式 如下 ：$&#123;file.encoding&#125; --&gt; &lt;properties&gt; &lt;file.encoding&gt;UTF-8&lt;/file.encoding&gt; &lt;java.source.version&gt;1.5&lt;/java.source.version&gt; &lt;java.target.version&gt;1.5&lt;/java.target.version&gt; &lt;/properties&gt; ...&lt;/project&gt; 2. 构建配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;build&gt; &lt;!-- 产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt; &lt;finalName&gt;myPorjectName&lt;/finalName&gt; &lt;!-- 构建产生的所有文件存放的目录,默认为$&#123;basedir&#125;/target，即项目根目录下的target --&gt; &lt;directory&gt;$&#123;basedir&#125;/target&lt;/directory&gt; &lt;!-- 当项目没有规定目标（Maven2 叫做阶段（phase））时的默认值， 必须跟命令行上的参数相同例如jar:jar，或者与某个阶段（phase）相同例如install、compile等 --&gt; &lt;defaultGoal&gt;install&lt;/defaultGoal&gt; &lt;!-- 当filtering开关打开时，使用到的过滤器属性文件列表。 项目配置信息中诸如$&#123;spring.version&#125;之类的占位符会被属性文件中的实际值替换掉 --&gt; &lt;filters&gt; &lt;filter&gt;../filter.properties&lt;/filter&gt; &lt;/filters&gt; &lt;!-- 项目相关的所有资源路径列表，例如和项目相关的配置文件、属性文件，这些资源被包含在最终的打包文件里。 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。 举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。 然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath&gt;resources&lt;/targetPath&gt; &lt;!-- 是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;!-- 描述存放资源的目录，该路径相对POM路径 --&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- 包含的模式列表 --&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;!-- 排除的模式列表 如果&lt;include&gt;与&lt;exclude&gt;划定的范围存在冲突，以&lt;exclude&gt;为准 --&gt; &lt;excludes&gt; &lt;exclude&gt;jdbc.properties&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 单元测试相关的所有资源路径，配制方法与resources类似--&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath /&gt;&lt;filtering /&gt;&lt;directory /&gt;&lt;includes /&gt;&lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!-- 项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;sourceDirectory&gt;$&#123;basedir&#125;\src\main\java&lt;/sourceDirectory&gt; &lt;!-- 项目脚本源码目录，该目录和源码目录不同， 绝大多数情况下，该目录下的内容会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt; &lt;scriptSourceDirectory&gt;$&#123;basedir&#125;\src\main\scripts&lt;/scriptSourceDirectory&gt; &lt;!-- 项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;testSourceDirectory&gt;$&#123;basedir&#125;\src\test\java&lt;/testSourceDirectory&gt; &lt;!-- 被编译过的应用程序class文件存放的目录。 --&gt; &lt;outputDirectory&gt;$&#123;basedir&#125;\target\classes&lt;/outputDirectory&gt; &lt;!-- 被编译过的测试class文件存放的目录。 --&gt; &lt;testOutputDirectory&gt;$&#123;basedir&#125;\target\test-classes&lt;/testOutputDirectory&gt; &lt;!-- 项目的一系列构建扩展,它们是一系列build过程中要使用的产品，会包含在running bulid‘s classpath里面。 他们可以开启extensions，也可以通过提供条件来激活plugins。 简单来讲，extensions是在build过程被激活的产品--&gt; &lt;extensions&gt; &lt;!-- 例如，通常情况下，程序开发完成后部署到线上Linux服务器，可能需要经历打包、 将包文件传到服务器、SSH连上服务器、敲命令启动程序等一系列繁琐的步骤。 实际上这些步骤都可以通过Maven的一个插件 wagon-maven-plugin 来自动完成 下面的扩展插件wagon-ssh用于通过SSH的方式连接远程服务器， 类似的还有支持ftp方式的wagon-ftp插件 --&gt; &lt;extension&gt; &lt;groupId&gt;org.apache.maven.wagon&lt;/groupId&gt; &lt;artifactId&gt;wagon-ssh&lt;/artifactId&gt; &lt;version&gt;2.8&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!-- 使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt; &lt;id&gt;assembly&lt;/id&gt; &lt;!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;!-- 配置的执行目标 --&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;!-- 配置是否被传播到子POM --&gt; &lt;inherited&gt;false&lt;/inherited&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!-- 作为DOM对象的配置,配置项因插件而异 --&gt; &lt;configuration&gt; &lt;finalName&gt;$&#123;finalName&#125;&lt;/finalName&gt; &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt; &lt;descriptor&gt;assembly.xml&lt;/descriptor&gt; &lt;/configuration&gt; &lt;!-- 是否从该插件下载Maven扩展（例如打包和类型处理器）， 由于性能原因，只有在真需要下载时，该元素才被设置成true。 --&gt; &lt;extensions&gt;false&lt;/extensions&gt; &lt;!-- 项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt;...&lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 任何配置是否被传播到子项目 --&gt; &lt;inherited&gt;true&lt;/inherited&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!-- 主要定义插件的共同元素、扩展元素集合，类似于dependencyManagement， 所有继承于此项目的子项目都能使用。该插件配置项直到被引用时才会被解析或绑定到生命周期。 给定插件的任何本地配置都会覆盖这里的配置 --&gt; &lt;pluginManagement&gt; &lt;plugins&gt;...&lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt; 3. 分发配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!-- 项目分发信息，在执行mvn deploy后表示要发布的位置。 有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt; &lt;distributionManagement&gt; &lt;!-- 部署项目产生的构件到远程仓库需要的信息 --&gt; &lt;repository&gt; &lt;!-- 是分配给快照一个唯一的版本号（由时间戳和构建流水号），还是每次都使用相同的版本号 参见repositories/repository元素 --&gt; &lt;uniqueVersion&gt;true&lt;/uniqueVersion&gt; &lt;id&gt; repo-id &lt;/id&gt; &lt;name&gt; repo-name &lt;/name&gt; &lt;url&gt; file://$&#123;basedir&#125;/target/deploy &lt;/url&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;!-- 构件的快照部署到哪里,如果没有配置该元素，默认部署到repository元素配置的仓库 --&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion /&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/snapshotRepository&gt; &lt;!-- 部署项目的网站需要的信息 --&gt; &lt;site&gt; &lt;!-- 部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt; &lt;id&gt; site-id &lt;/id&gt; &lt;!-- 部署位置的名称 --&gt; &lt;name&gt; site-name &lt;/name&gt; &lt;!-- 部署位置的URL，按protocol://hostname/path形式 --&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!-- 项目下载页面的URL。如果没有该元素，用户应该参考主页。 使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt; &lt;downloadUrl /&gt; &lt;!-- 如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt; &lt;relocation&gt; &lt;!-- 构件新的group ID --&gt; &lt;groupId /&gt; &lt;!-- 构件新的artifact ID --&gt; &lt;artifactId /&gt; &lt;!-- 构件新的版本号 --&gt; &lt;version /&gt; &lt;!-- 显示给用户的，关于移动的额外信息，例如原因。 --&gt; &lt;message /&gt; &lt;/relocation&gt; &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --&gt; &lt;status /&gt; &lt;/distributionManagement&gt; 4. 仓库配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!-- 发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!-- 包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!-- 如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!-- true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled /&gt; &lt;!-- 该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。 这里的选项是：always（一直），daily（默认，每日）， interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy /&gt; &lt;!-- 当Maven验证构件校验文件失败时该怎么做： ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置， POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。 例如，可能有人会决定只为开发目的开启对快照版本下载的支持 --&gt; &lt;snapshots&gt; &lt;enabled /&gt;&lt;updatePolicy /&gt;&lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!-- 远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt; repo-id &lt;/id&gt; &lt;!-- 远程仓库名称 --&gt; &lt;name&gt; repo-name &lt;/name&gt; &lt;!-- 远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt; http://192.168.1.169:9999/repository/ &lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。 Maven 2为其仓库提供了一个默认的布局； 然而，Maven 1.x有一种不同的布局。 我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt; default &lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!-- 发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!-- 包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository /&gt; &lt;/pluginRepositories&gt; 5. 报表配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- 描述使用报表插件产生报表的规范,特定的maven 插件能输出相应的定制和配置报表.当用户执行“mvn site”，这些报表就会运行,在页面导航栏能看到所有报表的链接。 --&gt; &lt;reporting&gt; &lt;!-- true，则网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt; &lt;excludeDefaults /&gt; &lt;!-- 所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt; &lt;outputDirectory /&gt; &lt;!-- 使用的报表插件和他们的配置。 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;inherited /&gt; &lt;configuration&gt; &lt;links&gt; &lt;link&gt;http://java.sun.com/j2se/1.5.0/docs/api/&lt;/link&gt; &lt;/links&gt; &lt;/configuration&gt; &lt;!-- 一组报表的多重规范，每个规范可能有不同的配置。 一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。 1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt; &lt;reportSets&gt; &lt;!-- 表示报表的一个集合，以及产生该集合的配置 --&gt; &lt;reportSet&gt; &lt;!-- 报表集合的唯一标识符，POM继承时用到 --&gt; &lt;id&gt;sunlink&lt;/id&gt; &lt;!-- 产生报表集合时，被使用的报表的配置 --&gt; &lt;configuration /&gt; &lt;!-- 配置是否被继承到子POMs --&gt; &lt;inherited /&gt; &lt;!-- 这个集合里使用到哪些报表 --&gt; &lt;reports&gt; &lt;report&gt;javadoc&lt;/report&gt; &lt;/reports&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; 6. 项目配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205&lt;!-- 项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt; &lt;issueManagement&gt; &lt;!-- 问题管理系统（例如jira）的名字， --&gt; &lt;system&gt; jira &lt;/system&gt; &lt;!-- 该项目使用的问题管理系统的URL --&gt; &lt;url&gt; http://jira.clf.com/ &lt;/url&gt; &lt;/issueManagement&gt; &lt;!-- 项目持续集成信息 --&gt; &lt;ciManagement&gt; &lt;!-- 持续集成系统的名字，例如continuum --&gt; &lt;system /&gt; &lt;!-- 该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt; &lt;url /&gt; &lt;!-- 构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt; &lt;notifiers&gt; &lt;!-- 配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt; &lt;notifier&gt; &lt;!-- 传送通知的途径 --&gt; &lt;type /&gt; &lt;!-- 发生错误时是否通知 --&gt; &lt;sendOnError /&gt; &lt;!-- 构建失败时是否通知 --&gt; &lt;sendOnFailure /&gt; &lt;!-- 构建成功时是否通知 --&gt; &lt;sendOnSuccess /&gt; &lt;!-- 发生警告时是否通知 --&gt; &lt;sendOnWarning /&gt; &lt;!-- 不赞成使用。通知发送到哪里 --&gt; &lt;address /&gt; &lt;!-- 扩展配置项 --&gt; &lt;configuration /&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt;&lt;!-- 项目的名称, Maven产生的文档用 --&gt; &lt;name&gt; banseon-maven &lt;/name&gt; &lt;!-- 项目主页的URL, Maven产生的文档用 --&gt; &lt;url&gt; http://www.clf.com/ &lt;/url&gt; &lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时 （例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签），不鼓励使用纯文本描述。 如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt; &lt;description&gt; A maven project to study maven. &lt;/description&gt; &lt;!-- 描述了这个项目构建环境中的前提条件。 --&gt; &lt;prerequisites&gt; &lt;!-- 构建该项目或使用该插件所需要的Maven的最低版本 --&gt; &lt;maven /&gt; &lt;/prerequisites&gt; &lt;!-- 项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt; &lt;inceptionYear /&gt; &lt;!-- 项目相关邮件列表信息 --&gt; &lt;mailingLists&gt; &lt;!-- 该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt; &lt;mailingList&gt; &lt;!-- 邮件的名称 --&gt; &lt;name&gt; Demo &lt;/name&gt; &lt;!-- 发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;post&gt; clf@126.com &lt;/post&gt; &lt;!-- 订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;subscribe&gt; clf@126.com &lt;/subscribe&gt; &lt;!-- 取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;unsubscribe&gt; clf@126.com &lt;/unsubscribe&gt; &lt;!-- 你可以浏览邮件信息的URL --&gt; &lt;archive&gt; http:/hi.clf.com/ &lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!-- 项目开发者列表 --&gt; &lt;developers&gt; &lt;!-- 某个项目开发者的信息 --&gt; &lt;developer&gt; &lt;!-- SCM里项目开发者的唯一标识符 --&gt; &lt;id&gt; HELLO WORLD &lt;/id&gt; &lt;!-- 项目开发者的全名 --&gt; &lt;name&gt; banseon &lt;/name&gt; &lt;!-- 项目开发者的email --&gt; &lt;email&gt; banseon@126.com &lt;/email&gt; &lt;!-- 项目开发者的主页的URL --&gt; &lt;url /&gt; &lt;!-- 项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;roles&gt; &lt;role&gt; Project Manager &lt;/role&gt; &lt;role&gt; Architect &lt;/role&gt; &lt;/roles&gt; &lt;!-- 项目开发者所属组织 --&gt; &lt;organization&gt; demo &lt;/organization&gt; &lt;!-- 项目开发者所属组织的URL --&gt; &lt;organizationUrl&gt; http://hi.clf.com/ &lt;/organizationUrl&gt; &lt;!-- 项目开发者属性，如即时消息如何处理等 --&gt; &lt;properties&gt; &lt;dept&gt; No &lt;/dept&gt; &lt;/properties&gt; &lt;!-- 项目开发者所在时区， -11到12范围内的整数。 --&gt; &lt;timezone&gt; -5 &lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!-- 项目的其他贡献者列表 --&gt; &lt;contributors&gt; &lt;!-- 项目的其他贡献者。参见developers/developer元素 --&gt; &lt;contributor&gt; &lt;name /&gt;&lt;email /&gt;&lt;url /&gt;&lt;organization /&gt;&lt;organizationUrl /&gt; &lt;roles /&gt;&lt;timezone /&gt;&lt;properties /&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!-- 该元素描述了项目所有License列表。应该只列出该项目的license列表，不要列出依赖项目的license列表。 如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt; &lt;licenses&gt; &lt;!-- 描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt; &lt;license&gt; &lt;!-- license用于法律上的名称 --&gt; &lt;name&gt; Apache 2 &lt;/name&gt; &lt;!-- 官方的license正文页面的URL --&gt; &lt;url&gt; http://www.clf.com/LICENSE-2.0.txt &lt;/url&gt; &lt;!-- 项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt; &lt;distribution&gt; repo &lt;/distribution&gt; &lt;!-- 关于license的补充信息 --&gt; &lt;comments&gt; A business-friendly OSS license &lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!-- SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt; &lt;scm&gt; &lt;!-- SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt; &lt;connection&gt;scm:svn:http://svn.baidu.com/banseon/maven/&lt;/connection&gt; &lt;!-- 给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt; &lt;developerConnection&gt;scm:svn:http://svn.baidu.com/banseon/maven/&lt;/developerConnection&gt; &lt;!-- 当前代码的标签，在开发阶段默认为HEAD --&gt; &lt;tag /&gt; &lt;!-- 指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt; &lt;url&gt; http://svn.baidu.com/banseon &lt;/url&gt; &lt;/scm&gt; &lt;!-- 描述项目所属组织的各种属性。Maven产生的文档用 --&gt; &lt;organization&gt; &lt;!-- 组织的全名 --&gt; &lt;name&gt; demo &lt;/name&gt; &lt;!-- 组织主页的URL --&gt; &lt;url&gt; http://www.clf.com/ &lt;/url&gt; &lt;/organization&gt; 7. 多版本如果settings中的profile被激活, 会覆盖其他在pom中带有相同id的profile 如果想默认激活某个profile, 配置该profile的id到\中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!-- 在列的项目构建profile，如果被激活，会修改构建处理 --&gt; &lt;profiles&gt; &lt;!-- 根据环境参数或命令行参数激活某个构建处理 --&gt; &lt;profile&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。--&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标识 --&gt; &lt;activeByDefault&gt;false&lt;/activeByDefault&gt; &lt;!--activation有一个内建的java版本检测，如果检测到jdk版本与期待的一样，profile被激活。 --&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 'windows') --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。 如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。 另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;id /&gt; &lt;build /&gt; &lt;modules /&gt; &lt;repositories /&gt; &lt;pluginRepositories /&gt; &lt;dependencies /&gt; &lt;reporting /&gt; &lt;dependencyManagement /&gt; &lt;distributionManagement /&gt; &lt;properties /&gt; &lt;/profile&gt;&lt;/profiles&gt; 8. 常用插件官方主要的插件库: http://maven.apache.org/plugins/index.html 次要插件库: http://mojo.codehaus.org/plugins.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;plugins&gt; &lt;plugin&gt; &lt;!-- 编译插件 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.5&lt;/source&gt; &lt;target&gt;1.5&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;!-- 发布插件 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;!-- 打包插件 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;!-- 安装插件 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;!-- 单元测试插件 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.7.2&lt;/version&gt; &lt;configuration&gt; &lt;skip&gt;true&lt;/skip&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;!-- 源码插件 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;!-- 发布时自动将源码同时发布的配置 --&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;attach-sources&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题01]]></title>
    <url>%2Fpost%2Fdabb34ff.html</url>
    <content type="text"><![CDATA[详情提要: 记一次面试题 一. Java基础 1. ClassLoader的加载过程 2. 堆和栈的区别 3. 临时变量存在哪里 4. 辣鸡回收如何判断一个对象是否需要被回收 5. 根搜索算法的起点有哪些 二. Spring相关 1. Spring中Bean的作用域 三. Dubbo和ZooKeeper 1. ZooKeeper的节点类型 2. ZooKeeper的节点存储结构 3. 服务注册到ZooKeeper上时是什么类型的节点, 为什么? 4. Dubbo的通讯协议 四. MySQL 1. MySQL有哪些引擎 2. InnoDB和MyISAM的区别 五. Redis 1. Redis常用数据类型 2. Redis如何设置过期时间 3. Redis如何更换key 一. Java基础1. ClassLoader的加载过程 加载: 通过类的完全限定名查找这个类的字节码文件, 读取这个类的二进制字节流到JVM中, 创建一个Class对象. 验证: 通过文件格式、元数据验证、字节码验证、符号引用四种验证方法验证Class文件, 确保字节流中的信息符合虚拟机要求, 不会危害虚拟机安全. 准备: 为类变量(主要是静态变量, final变量在编译期就分配了)分配内存并设置初始值为0(比如 static int a = 10, 则初始化为0, 10在下一步初始化), 这里不会为实例变量分配初始化, 类变量会分配在方法区中, 而实例变量会随着对象分配到Java堆中. 解析: 将常量池中的符号引用替换为直接引用. 初始化: 如果这个类有父类, 则初始化父类, 执行静态初始化器和静态初始化成员变量(前面的static int a), 成员变量也会在这一步被初始化. 2. 堆和栈的区别 堆内存用来存放由new创建的对象和数组, 该区域是共享的. 特点是先进先出, 后进后出. 可以动态分配内存大小, 存取速度较慢. 栈内存主要是用于执行程序, 包含基本类型的变量和对象的引用变量. 特点是先进后出, 后进先出. 大小需要先确定, 但存取速度较快. 存放栈帧, 每个栈帧对应被调用的一个方法, 其中包括局部变量表, 操作数栈, 指向运行时常量池的引用, 方法返回地址等. 3. 临时变量存在哪里​ 栈内存 4. 辣鸡回收如何判断一个对象是否需要被回收​ 根搜索算法(可达性分析) ​ 没有引用计数法! 那是js用的 5. 根搜索算法的起点有哪些 Java虚拟机栈中引用的对象, 比如局部变量 静态属性引用的对象 常量引用的对象 本地方法栈中引用的对象 二. Spring相关1. Spring中Bean的作用域 基本作用域(singleton、prototype)，Web 作用域(reqeust、session、global session), 自定义作用域. singleton: 单例 prototype: 原型模式, 每次通过容器获取都会产生新的实例. request: 对于每次HTTP请求, 使用request定义的Bean都会产生一个新的实例, 且只有在Web应用中使用Spring时, 该作用域才生效. session: 每次HTTP中使用session定义的Bean都会产生一个新的实例. 且只有在Web应用中使用Spring时, 该作用域才生效. global session: 每个全局的HTTP Session, 使用session定义的Bean都会产生一个新的实例. 典型情况仅在使用portlet context时有效, 且只有在Web应用中使用Spring时, 该作用域才生效. 三. Dubbo和ZooKeeper1. ZooKeeper的节点类型 持久节点: 在节点创建后就一直存在, 直到被删除, 不会因为客户端会话失效而清除. 持久顺序节点: 和普通持久节点不同的是每个父节点会为他的第一级子节点维护一份时序. 临时节点: 生命周期和客户端会话绑定, 客户端失效时节点自动清除. 且临时节点不能创建子节点. 临时顺序节点: 可以用于实现分布式锁. 2. ZooKeeper的节点存储结构​ 树形结构, 树上的节点可以是文件也可以是目录. 3. 服务注册到ZooKeeper上时是什么类型的节点, 为什么?​ 临时节点, 连接断开时节点被删除. 4. Dubbo的通讯协议1. Dubbo(缺省协议), 基于mina和hessian的tbremoting交互, 单一长连接的TCP NIO异步传输, 使用Hessian二进制序列化 2. rmi, 基于JDK标准的rmi实现, 多连接短链接TCP同步传输, 采用标准java二进制序列化 3. hessian, 底层为http 4. http, 基于HTTP表单序列化的http同步传输 5. webservice, 基于SIAP文本序列化的http同步传输 6. thrift 7. memcached 8. redis 9. rest, 基于标准Java Rest api. 支持xml和json序列化 四. MySQL1. MySQL有哪些引擎​ 主要有InnoDB和MyISAM 2. InnoDB和MyISAM的区别 InnoDB: 支持事务处理 不加锁读取 支持外键 支持行锁 不支持FULLTEXT类型的索引 不保存表行数, 需要全表扫描 DELETE时是一行一行删 数据和索引都存在表空间 MyISAM: 不支持事务, 回滚会造成不完全回滚, 不具有原子性 不支持外键 支持全文搜索 保存表行数 DELETE时先drop再重建 索引和数据分开存, frm存放表结构, MYD存放数据, MYI存放索引 五. Redis1. Redis常用数据类型​ String, Hash, List, Set, ZSet 2. Redis如何设置过期时间​ Expire命令 3. Redis如何更换key​ Rename]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>面试题</tag>
        <tag>ZooKeeper</tag>
        <tag>dubbo</tag>
        <tag>GC</tag>
        <tag>JVM</tag>
        <tag>redis</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次因连接池泄漏导致的生产事故]]></title>
    <url>%2Fpost%2F82537ad4.html</url>
    <content type="text"><![CDATA[一. 事故概述3月10号早上大批量用户反馈个人中心显示匿名用户, 无法正常下单, 无法查询到订单、优惠券等相关数据, 经查影响范围有20000多用户受到影响. 修了一天数据! 二. 排查过程日志中发现大量的错误, 如下图: 出现该错误主要是因为客户端无法从jedis连接池中获取连接对象. 在华为云监控中发现连接数从800多骤降到几十. 参考这一现象主要怀疑是连接池泄漏导致的redis-server关闭了空闲连接, 但客户端未关闭. 经过代码排查发现9号晚同事提交的代码中包含有直接获取连接池对象的操作, 并未按照工具类封装的方法进行命令调用, 该代码直接导致连接在使用完无法正常释放. 结合上下验证, 还原了事故起因. 代码引发的连接池泄漏 微信token无法正常刷新 用户被判定为新用户, 进行了合并操作. 另附两幅图, 分别是异常情况下的cause和正常因redis-server连接数过小导致的连接数不足: 三. 解决方案 优化泄漏代码, 将资源获取操作包裹到try-with-resource中. 经此次事故表明业务逻辑存在严重的不合理. 优化工具类, 隐藏掉可以直接操作对象的逻辑.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次生产事故的排查和解决]]></title>
    <url>%2Fpost%2Fbc6a8499.html</url>
    <content type="text"><![CDATA[一. 事故概述春节期间, 生产系统多次出现假死不可用现象, 导致绝大部分业务无法进行. 主要表现现象为接口无法访问. 背景为900W+客户表和近实时ES, 以及春节期间疫情导致的普通卖菜场景近似秒杀等. 二. 排查过程优先排查了info, error, catalina日志, 发现以下异常: 主要的异常信息为:12Cause: java.sql.SQLException: Lock wait timeout exceeded; try restarting transaction 引起该异常通常是由高频行锁或表锁同时操作数据库导致. 上一次事务还未完成, 新的事务尝试获取锁等待超时. 但根本原因是业务涉及缺陷或代码不合理导致的事务无法正常提交或事务体执行时间过长. 引起获取锁等待超时. 参考异常中的业务代码, 如1图中的库存扣减逻辑, 和2图中的购物车逻辑. 排查代码时发现库存扣减存在业务上设计的不合理, 原业务为在支付回调时扣减库存, 造成超卖现象很严重(甲方允许超卖), 扣减在update语句中实现, 库存字段为unsigned, 所以负数抛出异常导致事务无法正常提交. 在创建订单时的大事务体中包含购物车删除逻辑, 有很多查询, 创建, 删除操作数据库的逻辑, 在近秒杀场景中, 高频商品的记录被阻塞在事务中, 最终导致其他线程获取锁超时. 三. 解决方案比较主流的处理方案是查询以下几张表, 删除事务表中无法正常释放的事务锁记录 123information_schema.INNODB_TRX;information_schema.INNODB_LOCKs;information_schema.INNODB_LOCK_waits; 但基于事故发生的时间和严重程度, 该方案只能治标, 不能治本. 所以根据异常中两处不同的业务代码入手 发现共同点: 均存在大事务代码体, 个别业务存在事务期间刷新ES操作. 解决方案如下: 异步化刷新ES. 降低事务体大小和数据库操作, 将非强一致性要求的操作移到事务外. 酌情去除事务. 优化畸形代码(特指历史遗留或未经review的脏代码) 查询类接口考虑读写分离 利用缓存合理规避高频业务对数据库带来的压力 对于代码提交做把控, 有效的review可以减少脏代码的产生.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次RabbitMQ崩溃引发的宕机事故]]></title>
    <url>%2Fpost%2F321f3c05.html</url>
    <content type="text"><![CDATA[一. 事故概述19年12月一次升级, 针对和三方联调这边同事主动推送客户数据(800万左右)做初始化. 在部署到生产环境后进行推送, 突发系统宕机, 导致系统近8个小时无法正常访问. 二. 排查过程经日志发现RabbitMQ无法正常push, 在管理页面发现某队列过度积压甚至导致管理页面无法正常使用. 找到相关代码发现为主推数据给三方做初始化的相关业务. 代码层面发现以下问题: 推送的数据无查询范围限制. 推送频率无控制. 推送主体写到了主服务里. 三. 解决方案在第一时间还原代码, 停止了问题业务. 联系华为云开发修复mq. 经华为云开发排查, 是因瞬时数据量过大导致的内存申请不足, 引发内存溢出. 另外因进程崩溃导致segment(消息在存储时每个parttition按segment保存自己的消息为文件)和journal(journal文件是queue_index为避免过多磁盘寻址添加的一层缓冲, 类似内存文件)不一致, 此类脏数据影响了RabbitMQ的自重启, 云服务就此宕机. 解决方案如下: 移除了该业务. 改用提供数据服务和接口的方式给三方进行调用(对方很不乐意) 联系了甲方DBA对三方所需数据进行导出, 做线下导入. 在不进行移除的场景, 控制查询条件和推送频率. 要求三方提供压测数据, 从而调整推送频率和条数. 经尝试对方的接口消费量低于正常值, 一次只能消费一条数据. 在推送100条一次时发生了服务崩溃. 所以停止了本方案, 选择了第一个方案.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String, StringBuffer, StringBuilder测试]]></title>
    <url>%2Fpost%2F516d2f4f.html</url>
    <content type="text"><![CDATA[测试String, StringBuffer, StringBuilder的拼接速度, 内存使用情况比较. 测试采用随机数拼接, 指定数量的随机数初始化的list进行循环顺序拼接. 详细代码在test中. 图中分别是 1万和100万的测试数据. 100w的测试中没使用字符串拼接, 太慢了. 在比较中发现StringBuffer会比StringBuilder多近一倍的内存占用.原因是因为StringBuffer在对象实例内会存有toString的缓存, 详情参考bufferInfo.txt文件第八行. 这个改动是1.8新增的, 所以在1.7及以前是没有的. 不过不用担心, 该变量不参与序列化.具体就是在toString的时候会生成一个cache数组, 作为缓存使用.所以在非多线程环境中, 尽(必)量(须)使用StringBuilder作为字符串拼接工具.]]></content>
      <tags>
        <tag>java</tag>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java常见面试题]]></title>
    <url>%2Fpost%2F44e3c230.html</url>
    <content type="text"><![CDATA[逐步更新中. Java基础常见面试题(仅浅显答案) 1. 数组和链表 2. 集合类 3. 线程 Spring常见面试题(仅常见) 1. 你对Spring有什么了解(Really? 要这么问?) 2. Spring的IOC和AOP 3. 核心容器Application Context(上下文) 4. AOP是什么, 原理, 配置, 场景 5. IOC 6. BeanFactory和Application Context的区别 7. Spring框架中的单例bean是线程安全的吗? 8. @Autowired和@Resource的区别 9. Spring支持的事务管理类型 10. SpringMVC的请求流程 11. @Controller和@RestController的区别 Spring Boot常见面试题(近常见) 1. SpringBoot是什么? 和SpringMVC有什么区别? 2. SpringBoot的核心配置有什么? 区别是什么? 3. SpringBoot的核心注解是哪个? 都包含什么功能? 4. SpringBoot的自动配置原理 5. 怎么在SpringBoot服务启动时加载一些代码 6. SpringBoot读取配置的方式 7. 实现热部署的方式 Spring Cloud常见面试题(拙见, 较少) 1. SpringCloud和Dubbo的区别 2. Eureka和ZooKeeper的区别 4. SpringCloud中如何独立通讯 5. 服务熔断和服务降级 6. 微服务技术栈都有哪些? Dubbo常见面试题 Netty常见面试题 Mybatis常见面试题(都是一些常见简单的) 1. #{}和${}的区别 2. 当实体类中的属性名和表中的字段名不一样 3. 如何在插入后获取主键 4. 在mapper中如何传递多个参数 5. 动态sql, 都有哪些标签, 执行原理 6. 在xml映射文件中, 不同的xml映射文件id是否可以重复 7. dao接口和xml的映射工作原理是什么? 能否重载? 8. Mybatis的分页和分页插件的分页有什么区别? MySQL常见面试题 1. 常见的引擎和区别 2. 意向锁 3. MySQL的事务特征和隔离级别 4. 索引 5. SQL编写 Java基础常见面试题(仅浅显答案)1. 数组和链表 数组是将元素在内存中连续存放, 通过下标迅速访问, 但是插入元素可能会导致移动大量的元素, 删除同理. 链表的元素在内存中不是顺序排序, 而是通过元素中的指针连在一起, 在访问时只能从第一个开始一个个的走. 但是增加和删除只需要修改元素指针即可. 2. 集合类 常见的集合类接口有List和Set, Set是一种不包含重复元素的集合. 常见的List实现有: ArrayList: 有序可变数组, 允许null, 线程不安全. LinkedList: 有序链表, 允许null, 线程不安全, 通常用来实现队列(queue)或堆栈(stack). Vector: 类似ArrayList, 使用synchronized同步, 线程安全. Stack: 继承自Vector, 实现了一个先进后出的堆栈. 具有基本的push和pop方法. set: 无序列表, 元素不可重复, 否则覆盖. HashSet中不能重复是由HashMap的key实现的, 但本身是线性结构. Map: 键值对的集合, key不允许重复 HashMap: 线程不安全, 数组+链表的结构, 采用链地址法解决哈希碰撞, 初始长度16, 扩容为2倍, 初始长度自定义为奇数则会顺延到最近的一个2的倍数值. JDK1.8后在扩容到64时会转为红黑树. HashTable: 线程安全的HashMap, 使用synchronized同步, 效率慢. 不允许空键值对. TreeMap: 线程不安全, 基于红黑树实现, 无调优选项, 因为总处于平衡状态. ConCurrentHashMap: 线程安全的HashMap, JDK1.7中采用分段锁实现线程安全, Segment继承于ReentrantLock, 理论上支持Segment数组数量的线程并发, 当一个线程占用锁访问一个Segment时, 不会影响其他的Segment. value和链表都是使用volatile修饰, 保证透明度.get的时候不需要加锁. JDK1.8中采用cas+synchronized保证并发安全, HashEntry换成了Node, 作用一样. 和HashMap一样也采用了红黑树结构. 3. 线程 创建线程的方式 继承Thread类, run()是方法实现, 启动时用start(). 实现Runnable/Callable接口, Callable有返回值(Future) 线程池, ThreadPoolExecutor(核心线程数, 最大线程数, 超时时间, 时间单位, 队列, 线程工厂(主要用来创建线程, 比如可以指定线程的名字, 非必填), handler(如果线程池满了, 新任务的处理方式, 非必填)). ThreadPoolExecutor详解 java提供的线程池: newFixedThreadPool: 固定大小的线程池. newCachedThreadPool: 可缓存线程池, 一般不用, 因为初始化最大线程数是Integer.MAX_VALUE. newScheduledThreadPool: 定长线程池, 常用于定时及周期性任务执行. newSingleThreadExecutor: 单线程线程池, 不适用于并发. 阻塞队列 ArrayBlockingQueue: 有边界的阻塞队列, 内部是一个数组, 且初始化后不能改变容量. DelayQueue: 内部元素必须实现 java.util.concurrent.Delayed接口, 常用于定时关闭链接, 缓存对象, 超时处理等. LinkedBlockingQueue(最常用): 无边界队列, 由链表实现. 未指定大小时默认为Integer最大值. 所以一般会指定一个值, 否则可能会撑爆JVM. PriorityBlockingQueue: 无边界队列. 允许插入null对象. 且内部元素必须实现java.lang.Comparable接口. SynchronousQueue: 单元素队列, 插入一个元素后阻塞, 除非这个元素被消费. 线程的几种状态 初始(NEW): 新创建了一个线程对象, 但还没调用start()方法. 运行(RUNNABLE): 就绪(ready)和运行中(running)都被认为是运行状态. 阻塞(BLOCKED): 阻塞于锁. 等待(WAITING): 线程等待被唤醒. 超时等待(TIMED_WAITING): 于等待不同, 可以超时后返回. 终止(TERMINATED): 表示线程执行完毕. Spring常见面试题(仅常见)1. 你对Spring有什么了解(Really? 要这么问?) Spring是一个java企业级应用的轻量级开源开发框架. 简化了java应用开发. Spring的核心是IOC和AOP 2. Spring的IOC和AOP IOC是控制反转, Spring通过控制反转实现了松散耦合, 将对象的依赖交由Spring进行管理 AOP是面向切面, Spring通过切面把应用业务逻辑和系统服务分开, 比如日志切面. 3. 核心容器Application Context(上下文)​ Application Context是Spring中较高级的容器, 底层也是继承了BeanFactory, 可以加载XML中的bean, 将其集中起来, 在有请求的时候分配bean. ​ 常见的实现类有: 1. ClassPathXmlApplicationContext: 默认为项目的classpath相对路径. 2. FileSystemXmlApplicationContext: 默认为项目的工作路径, 即项目的根目录. 3. XmlWebApplicationContext: 默认为项目的/WEB-INF/目录下. 4. AOP是什么, 原理, 配置, 场景 AOP把应用分成两个部分: 核心关注点和横切关注点, 业务主要处理的是核心关注点, 与其关系不大的部分是横切关注点. 主要作用在于分离系统中的各种关注点. AOP的原理在于Spring的动态代理, 这样不会对代码进行修改, 而是在内存中生成AOP代理对象, 在特定切点做增强处理, 并回调原对象的方法. 代理方式分两种: JDK动态代理和CGLIB动态代理, 不同的是JDK的动态代理是通过反射来接收被代理的类, 且要求和被代理类实现一个接口, 核心是InvocationHandler接口和Proxy类. 如果目标类没有实现该接口, 则会用CGLIB来动态代理目标类, CGLIB是通过运行时动态生成某个类的子类, 所以如果目标类是final则无法进行代理. 可以通过@Aspect标记切面, 其他的注解有@Pointcut定义切点, @Round, @Before, @After, @AfterReturning, @AfterThrowing. 执行顺序也是如此. AOP的场景可以有事务管理, 日志, 缓存, 权限等. 5. IOC​ IOC负责创建对象, 管理对象(通过DI, 依赖注入), 装配对象, 配置对象, 并管理这些对象的生命周期. 6. BeanFactory和Application Context的区别​ Application Context提供一种方法处理文本消息, 通常表现为加载文件资源. 而且继承了MessageSource接口, 可以实现可插拔的方式提供获取本地化消息的方法. 7. Spring框架中的单例bean是线程安全的吗?​ 不是 8. @Autowired和@Resource的区别 Autowired是由Spring提供, 默认按类型装配, 且要求依赖对象必须存在, 可以通过设置required属性为false来允许null值, 想使用名称装配可以使用@Qualifier注解 Resource是JDK1.6支持的注解, 默认按照名称装配.名称可以通过name属性指定, 如果没有则默认去字段名进行名称查找. 两个注解在便利程度上是相同的. 9. Spring支持的事务管理类型 编程式事务管理: 可以通过编程的方式管理事务, 灵活但难以维护. 声明式事务管理: 将业务代码和事务管理分开, 只需要注解和XML配置来管理事务.(推荐) 10. SpringMVC的请求流程​ 用户发送请求, DispatcherServlet接收请求, 通过映射处理器适配到对应的Handler, 调用响应方法处理, 返回视图, 经过视图解析和渲染返回给用户. 11. @Controller和@RestController的区别​ @RestController相当于@ResponseBody + @Controller, 不能返回页面. Spring Boot常见面试题(近常见)1. SpringBoot是什么? 和SpringMVC有什么区别?​ SpringBoot是由Spring开源组织Pivotal基于Spring开发的开源框架, 是Spring组件的一站式解决方案, 简化了Spring繁琐的配置, 提供了各种启动器. 可以独立运行, 无代码和XML生成, 简化配置, 自动配置等. 2. SpringBoot的核心配置有什么? 区别是什么? application和bootstrap, 可以是yml或者properties. yml不支持@PropertySource注解导入配置. application是主要配置文件, 用于自动配置. bootstrap一般用于Spring Cloud配置, 一些固定不能被覆盖的属性, 一些加密/解密的场景. 加载顺序在application之前. 3. SpringBoot的核心注解是哪个? 都包含什么功能?​ @SpringBootApplication @SpringBootConfiguration, 实现配置文件的功能. @EnableAutoConfiguration, 开启自动配置, 也可以添加属性exclude关闭某个自动配置功能. @ComponentScan, 组件扫描. 4. SpringBoot的自动配置原理​ 在MATA-INF下面有Spring.factories文件, 都是需要自动配置的类. 启动时会读取这个文件进行自动配置. 5. 怎么在SpringBoot服务启动时加载一些代码 @PostContrust, java原生注解, 属于构造器注入, 在类被加载时执行 ApplicationRunner接口, 启动获取应用启动时的参数. CommandLineRunner接口, 启动获取命令行参数. 可以通过实现Orderd接口或者@Order注解来实现启动顺序. 6. SpringBoot读取配置的方式 @PropertySource @Value @Environment @ConfigurationProperties 7. 实现热部署的方式 Spring Loaded Spring-boot-devtools Spring Cloud常见面试题(拙见, 较少)1. SpringCloud和Dubbo的区别 SpringCloud在调用方式上使用Rest API, Dubbo使用RPC远程调用, 在微服务中, RPC对于服务提供方和调用方来说依赖太高, 容易出现版本错误, Rest为轻量级接口, 不存在代码之间的耦合, 比RPC更加灵活. 功能上SpringCloud有20多个子项目, Dubbo近实现了服务治理. SpringCloud使用Netflix的Eureka作为注册中心, Dubbo使用ZooKeeper. SpringCloud在社区活跃以及生态上比Dubbo要强的多. 2. Eureka和ZooKeeper的区别 ZooKeeper保证的是CP(一致性和分区容错性), Eureka保证的是AP(高可用和分区容错) ZooKeeper在选举期间注册服务瘫痪, 虽然服务最终会恢复, 但是选取期间不可用. Eureka各个节点平等, 有一个就可以保证可用, 但是查到的数据不是最新的. Eureka的自我保护机制, ZooKeeper反而会导致整个注册系统瘫痪 Eureka不再从注册列表移除因心跳而应该过期的服务. Eureka仍然会接受新服务的注册和查询请求, 但不会被同步到其他节点.(高可用) 当网络稳定时, 新的注册信息会被同步到其他节点.(最终一致性) 4. SpringCloud中如何独立通讯 远程过程调用(RPI), 也就是服务的注册和发现, 直接通过远程过程调用访问别的Service 优点: 简单, 没有中间件代理, 系统更简洁. 缺点: 只支持请求/响应, 不支持比如通知, 异步响应, 发布/订阅, 订阅的异步响应. 消息, 使用异步消息通讯, 服务和服务之间通过消息管道. 优点: 可用性高, 也支持请求/响应, 不支持比如通知, 异步响应, 发布/订阅, 订阅的异步响应等. 缺点: 消息中间件的额外复杂性. 5. 服务熔断和服务降级 服务降级一般指服务在高并发下产生了阻塞, 导致当前线程不可用, 服务器的线程全部堵塞, 导致服务器的崩溃. 当某个服务调用响应时间过长或不可用占用资源达到一定阈值, 根据业务进行一些策略上的不处理或者简单处理, 释放资源保证核心服务的正常运转. 常见的降级情况有: 超时降级, 失败次数降级, 故障降级, 限流降级. 熔断一般指某个服务故障或者异常等异常条件时, 熔断器打开, 直接熔断整个服务, 进入指定的熔断逻辑, 在请求时直接返回fallback的值, 而不是一直等待超时或者一直报错. 经过一段时间后, 熔断器会进入半开状态, 允许通过一个请求, 当调用成功时, 熔断器恢复关闭状态, 请求失败则继续保持打开, 直到下一个半开时间. 6. 微服务技术栈都有哪些? 服务开发: Spring, SpringBoot, SpringMVC 注册中心: Netflix-Eureka, ZooKeeper 服务调用: Rest, RPC 熔断: Hystrix 负载均衡: Ribbon, Nginx 服务接口调用: Dubbo, Feign 消息队列: Kafka, RabbitMQ等 配置中心: SpringCloudConfig 网关: Zuul 消息总线: SpringCloudBus Dubbo常见面试题Netty常见面试题Mybatis常见面试题(都是一些常见简单的)1. #{}和${}的区别​ #{}解析传递进来的参数数据, ${}则是原样拼接. ​ #{}是预编译处理, 可以有效的防止SQL注入, ${}是字符串替换. 2. 当实体类中的属性名和表中的字段名不一样 通过在查询的sql语句中定义字段名的别名, 使其和实体类的属性名一致. 通过\做字段映射(一般是首选) 3. 如何在插入后获取主键​ 通过selectKey, 执行select LAST_INSERT_ID()获取 4. 在mapper中如何传递多个参数 #{0}, #{1}按照顺序指定(不推荐) 通过@Param(name), @Param(code)指定#{name}, #{code} 通过map, 用法同2, 需指定parameterType=”map” 5. 动态sql, 都有哪些标签, 执行原理 动态sql是在XML映射文件或者代码中, 通过条件判断动态拼接出来的sql. Mybatis提供了9种动态sql标签: trim, where, set, foreach, if, choose, when, otherwise, bind 执行原理是使用OGNL从sql参数对象中计算表达式的值, 再根据值动态拼接sql. 6. 在xml映射文件中, 不同的xml映射文件id是否可以重复​ 如果配置了namespace可以. 7. dao接口和xml的映射工作原理是什么? 能否重载? dao接口(mapper接口)的全限名, 就是映射文件的namespace, 接口中的方法就是映射文件中MappedStatement的id值, 接口方法中的参数就是传递给sql的参数. 工作原理是JDK的动态代理, 运行时会为接口生成代理对象, 代理对象拦截接口方法, 转而执行MappedStatement所代表的sql, 然后返回结果. 不可以重载. 因为全限名+方法名是映射的寻找策略. 8. Mybatis的分页和分页插件的分页有什么区别? Mybatis的分页是通过针对ResultSet结果集执行的内存分页. 分页插件是通过Mybatis提供的插件接口, 拦截sql进行物理分页的参数拼接(limit x, y). MySQL常见面试题1. 常见的引擎和区别 InnoDB和MyISAM InnoDB支持事务, MyISAM不支持, InnoDB执行每一条sql都会默认封装成事务自动提交. InnoDB支持外键, MyISAM不支持, 包含外键的InnoDB表转为MyISAM会失败. InnoDB是聚集索引, 数据文件和索引是绑在一起的, 必须有主键. 索引查询也会先查询到主键, 再通过主键查询到数据. 所以主键不应该太大, 会导致其他索引也很大. MyISAM是非聚集索引, 索引是保存数据文件的指针, 主键和其他索引是独立的. InnoDB不保存表的行数, count时为全表扫描. MyISAM用一个变量保存了整个表的行数, count时直接返回. InnoDB不支持全文索引, MyISAM支持, 所以在查询效率上MyISAM更高. InnoDB提供行锁, MyISAM不提供. 2. 意向锁 首先InnoDB引擎支持行锁, 行锁分为: 共享锁: 一个事务读一行的数据, 阻止其他事务获得这一行数据的排他锁. 排他锁: 一个事务对一行数据进行修改, 阻止其他事务获得这一行数据的共享锁和排他锁. 当一个读取的事务A需要读a行, 在数据库内部会判断在给a行加共享锁之前先取得意向共享锁. 当一个修改的事务B需要修改b行, 在数据库内部会判断给b行加排他锁之前先取得意向排他锁. InnoDB的锁是通过索引上的索引项实现的, 当使用非索引条件检索数据则会变为表锁. 意向锁可以通过显式的在select语句后面加LOCK IN SHARE MODE和FOR UPDATE进行加锁. 但注意事务不要造成死锁. 3. MySQL的事务特征和隔离级别 事务具有4个特征: 原子性(A): 事务中要么都成功, 要么都失败. 一致性(C): 事务的执行结果必须是从一个一致性状态变到另一个一致性状态. 比如转账的前后金额变化. 隔离性(I): 事务的执行不能受到其他事务的干扰. 持久性(D): 事务一旦提交, 对数据库的改变就是永久性的. 隔离级别有4种: 读未提交: 脏读. 读已提交: 大部分数据库的默认隔离级别, 但不是MySQL的. 也叫不可重复读. 可重复读: MySQL的默认隔离级别. 会出现幻读. 使用其作为默认隔离级别主要因为语句级的Binlog, 详情请自行查询. 串行化: 强制排序执行. 4. 索引 实现方式有BTREE(默认)和HASH. 类型分三种: 普通索引: 无任何约束. 唯一索引: 具有唯一性约束. 可有多个唯一索引. 主键索引: 特殊的唯一索引, 不允许有空值. 一个表只能有一个主键索引. 复合索引: 多个列组合一起创建索引, 可以是普通也可以是唯一, 覆盖多个列. 创建原则: 最适合的列是出现在where或on字句中的列, 或者连接字句中的列. 而不是出现在select关键字后面的列. 索引列的基数越大, 数据区分度越高, 效果越好. 根据情况创建复合索引, 更好的提高查询效率. 避免创建过多的索引, 会额外占用磁盘空间, 降低写操作的效率. 主键尽量选择较短的数据类型. 索引失效的情况: 复合索引的乱序使用. LIKE关键字, %不能在前, 可用position代替. null值其实会走索引, 但是会导致索引和索引统计更复杂. 当数据库判断使用索引比全表扫描还慢时, 比如where id&gt;1 and id&lt;100 or关键字前面的条件中的列有索引, 后面的没有, 则都不会生效. 字符串类型的列在查询时一定要加引号, 否则不会走索引. 索引上做计算或函数或类型转换. 范围条件(between, &lt;, &gt;)右边的列将不走索引, 比如where age&gt;10 and name = ‘tom’ &lt;,&gt;,!= 无法走索引. is null, is not null无法走索引 优化 用exists代替in 避免在where字句中进行表达式或者子查询 or可以换成union. in的列表中, 将出现最频繁的放在前面, 可以减少判断次数. 尽量使用&gt;=而不是&gt; 更多的查看这里. 5. SQL编写 学生表(Student), 课程表(Course), 教师表(Teacher), 成绩表(Score) 查询平均成绩大于60分的学生学号和平均成绩 1select s.sno as '学号', avg(s.score) as '平均成绩' from Score s group by s.sno having avg(s.score)&gt;60 查询至少选修两门课的学生学号 1select s.sno from Score s group by s.sno having count(s.sno)&gt;=2 其他参考]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springboot</tag>
        <tag>springcloud</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm的学习笔记]]></title>
    <url>%2Fpost%2Fd6b23368.html</url>
    <content type="text"><![CDATA[JVM是java的核心和基础, 介于java编译器和操作系统之间的虚拟处理器. java编译器通过编译java源代码, 得到JVM能理解的代码或字节码文件, 通过JVM将每一条指令翻译成不同平台的机器码, 通过平台运行. 一 JVM执行程序的过程: 加载 .class 文件 管理并分配内存 执行垃圾收集 二 类加载的过程: 类加载是指通过类的全限定名获取类的二进制字节流, 将字节流代表的静态存储结构转化为方法区的运行时数据结构. 在内存中生成这个类的class对象 加载, 通过类的全限定名获取类的二进制字节流. 连接, 包括: 验证class文件中字节流包含的信息符合当前虚拟机要求, 且不危害虚拟机自身安全. 正式为类变量分配内存并设置类变量初始值. 将常量池的符号引用替换为直接引用 根据程序员意愿初始化类变量. 三 对象的内存划分 对象头: 包含mark world和类型指针 mark world包含hash码, GC分代年龄, 锁状态标志等. 类型指针是用来确定这个对象是哪个类的实例. 实例数据: 是对象存储的真正有效信息. 对齐填充: hostspot虚拟机要求对象的大小必须是8字节的整数倍. 四 JVM的内存划分 线程独享区 java栈: 存放栈帧, 每个栈帧对应被调用的一个方法, 其中包括局部变量表, 操作数栈, 指向运行时常量池的引用, 方法返回地址等. 本地方法栈 与java栈作用和原理类似, 不过执行的都是本地方法. 程序计数器 保存程序当前执行的指令地址. 线程共享区 堆 用来存储对象和数组 方法区 存储类信息, 静态变量, 常量, 编译后的代码. 五 运行时常量池和字符串常量池的区别(intern)在new String(), 或调用intern方法时, 如果字符串常量池中不存在, 就会创建一个, 有则直接返回已存在的. 在JDK1.6, 字符串常量池和运行时常量池都在方法区. 自1.7开始, 字符串常量池被移动到堆中. 六 内存泄漏和内存溢出 内存泄漏: 分配出去的内存无法被回收 常见的分析策略是查看当前的内存分配, 找出占用内存居高不下的对象, 在代码中进行优化. 内存溢出: 程序需要分配的内存超过了系统能分配的范围. 七 GC中如何判断对象是否存活 引用计数: 略 可达性分析法: 到GC Root可达, 判定为不可回收的对象. GC Root是虚拟机栈, 本地方法栈, 方法区静态属性, 方法区常量所引用的对象 八 垃圾收集算法 标记-清除算法: 标记所有对象, 标记完统一回收. 效率不高, 且容易产生碎片 复制算法: 将内存划分成一块大的Eden空间(80%)和两块小的Survivor空间(10%), 每次使用Eden和其中一块Survivor, 回收时, 将两者中存活的对象复制到空闲的Survivor中, 清空之前用到的空间. 如果这块Survivor空间不够, 使用分配担保机制, 将多出的对象存在老年代. 标记-整理算法: 标记出所有对象, 回收时让存活的对象向一端移动, 直接清理端边界外的内存. 分代收集算法: java堆分为新生代和老年代, 垃圾回收时, 新生代采用复制算法, 处理大量需要回收的对象, 老年代存活的对象较多, 使用标记-清除或者标记-整理. 九 常见的垃圾收集器 Serial: 单线程收集器 ParNew: 新生代收集器, Serial的多线程版本 Parallel Scavenge: 新生代收集器, 采用复制算法, 实现最大吞吐量 Serial Old: Serial的老年代版本 Parallel Old: ParNew的老年代版本 CMS: 以获取最短停顿时间为目标的收集器 初始标记: 标记GC Root能直接关联到的对象 并发标记: 进行GC Root Tracing 重新标记: 修正并发标记期间用户线程继续工作导致的标记变动 并发清除: 清除未被标记的对象 G1: 独立管理整个gc堆 ( 初始标记, 并发标记, 最终标记, 筛选回收 ) 十 什么情况下对象会进入老年代 大对象(需要大量连续空间的对象), 常见的为很长的字符串或者数组 长期存活的对象, 每度过一次Minor GC, 年龄+1, 增长到一定程度(默认为15, 可以通过MaxTenuringThreshold设置), 进入老年代 动态年龄判断, 如果Survivor空间某个年龄的对象累计大小超出了其空间的一半(默认为50%, 可以通过TargetSurvivorRatio设置), 则大于或等于该年龄的对象都会进入老年代 空间分配担保: 复制算法中会将无法容纳的对象进行处理 十一 GC进行GC的时间是无法直接控制的, 只有当Eden区满了会出发minor GC, 老年代满了或调用System.gc会进行full GC. 不过需要注意的是, 此函数建议JVM进行主GC, 虽然只是建议而非一定, 但很多情况下它会触发主GC, 从而增加主GC的频率, 也即增加了间歇性停顿的次数]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清理Twitter]]></title>
    <url>%2Fpost%2Fbb1895ee.html</url>
    <content type="text"><![CDATA[常年搁置的Twitter账号总是被拿去做广告, 转发各种垃圾推文. 辣么如何在找回之后清理呢. 使用方法很简单, 不过不是全自动哦. Step 1, 清理推文 进到主页https://twitter.com/yourAccount 在头像的右侧选择Tweets标签(一般默认就是这里), 然后一直下拉到底部, 因为清理的只是当前显示的. 右键检查或者F12进入控制台, 选择Console, 粘贴并执行下面的脚本, 等待一会就OK了. 1$(&quot;.js-actionDelete&quot;).each(function()&#123;$(this).click()$(&quot;.delete-action&quot;).get(0).click()&#125;) Step 2, 清理转推 刷新页面. 剩下的这些没有删除提示的就是转推了. 同样一直下拉到底部, 粘贴脚本, 执行, 等一会就可以了1$(&quot;.js-actionRetweet&quot;).each(function()&#123;$(this).click()&#125;) Step 3 点击头像右侧的Following, 一直下拉到底部, 粘贴并执行脚本, 等一会就全部UnFollow了. 不要在当前页面重复执行哦. 点一次是取消, 再点一次可就是又关注了.1$(&quot;.following .js-follow-btn&quot;).click()]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Twitter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm的内存划分(1.7+)笔记]]></title>
    <url>%2Fpost%2F14515.html</url>
    <content type="text"><![CDATA[程序计数器: 没有OOM, 线程私有, 线程间互不干扰, 用来指示线程执行指令地址的. Native方法没有计数器值. 虚拟机栈: 线程私有, 生命周期同线程, 方法在执行的时候会创建一个栈帧用来存局部变量, 动态链接, 方法出口等信息. 一个方法从调用到执行完毕, 对应着一个栈帧从入栈到出栈. 通常被称为”栈内存”. 当线程请求的栈深度大于虚拟机所允许的深度, 抛出StackOverflowError. 如果虚拟机栈可以动态扩展(Java可以动态扩展也可以固定长度), 在扩展时若无法申请到足够内存则抛出OutOfMemoryError. 本地方法栈: 作用类似虚拟机栈, 不过本地方法栈执行Native方法. 也会有StackOverflowError和OutOfMemoryError出现. 方法区: 线程共享, 存储类的信息、常量池、方法数据、方法代码(编译器编码后的)等.”java.lang.OutOfMemoryError: PermGen space “就是指的方法区. 堆: 内存最大, 线程共享, 在虚拟机启动时创建. 用作存放对象实例, 也是GC的主要区域. 细分为新生代和老年代. 永久带: 1.8之后永久带转换成了元空间(Metaspace), 且PermSize 和 MaxPermSize 会被忽略并给出警告. 在1.7中开始移除, 但未完全移除. 其中原因可能有: 字符串在永久带中不利于GC, 容易出现性能问题和内存溢出. 类和方法的信息比较难确定大小, 所以永久带不好指定大小, 大了老年代溢出, 小了永久带溢出 元空间: 元空间内存储的类元数据的生命周期等于该类的类加载器生命周期, 不再单独回收某各类, 且对象的位置是固定的, 当类加载器不再存活, 被gc声明死亡后, 该类加载器对应的空间就会被回收. 元空间使用-XX：MinMetaspaceFreeRatio和-XX：MaxMetaspaceFreeRatio进行调节. 常量池: 方法区的一部分. 用于存放编译期和运行时生成的各种字面量和符号引用. 比如String类的intern方法 直接内存: 也就是堆外内存, NIO可以通过Native函数直接分配, 通过在堆中的DirectByteBuffer作为引用进行操作. 注意内存泄漏导致的OOM.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机获取图片的API收集]]></title>
    <url>%2Fpost%2F18256.html</url>
    <content type="text"><![CDATA[食用方法可以是img标签嵌入在网页中, 也可以在iwall.app里面设置你的桌面背景. 速度: ★★★★★ 功能: 返回Bing的随机图片 地址: https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture 速度: ★★★★★ 功能: 返回随机图片, 需指定分辨率, 如果指定的分辨率没有找到图片则返回空页面 地址: http://lorempixel.com/1600/900 速度: ★★★★☆ 功能: 来自github的项目https://github.com/xCss/bing 地址: https://bing.ioliu.cn/v1/rand (返回随机图片) ​ https://bing.ioliu.cn/v1/rand?w=1920&amp;h=1200 (指定大小) 12345678910111213141516171819/** * 已知分辨率 */resolutions: [ &apos;1920x1200&apos;, &apos;1920x1080&apos;, &apos;1366x768&apos;, &apos;1280x768&apos;, &apos;1024x768&apos;, &apos;800x600&apos;, &apos;800x480&apos;, &apos;768x1280&apos;, &apos;720x1280&apos;, &apos;640x480&apos;, &apos;480x800&apos;, &apos;400x240&apos;, &apos;320x240&apos;, &apos;240x320&apos;] 速度: ★★☆☆☆ 功能: 返回指定分辨率的随机图片, (加载最慢, 可能是因为服务器在国外) 地址: https://unsplash.it/1600/900?random 速度: ★★★★★ 功能: 返回随机的二次元图片, 国人之作, 发现地址: https://www.dujin.org/12142.html/amp 地址: https://api.xjdog.cn/Get-Image 速度: ★★★★★★ 功能: 返回随机Bing图片, 其中数字为分辨率, 例如 1366x768 -&gt; 1366, 1920x1080 -&gt; 1920 地址: https://api.dujin.org/bing/1366.php ​ 还有其他好用的API吗? 请在下放留下您的评论. 非常感谢!]]></content>
      <categories>
        <category>Image</category>
      </categories>
      <tags>
        <tag>img</tag>
        <tag>随机图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8 Files和Paths 踩坑记录]]></title>
    <url>%2Fpost%2F23178.html</url>
    <content type="text"><![CDATA[咩.java7引进的java.nio.file包的Files和Paths还有其他工具类, 以代替File和各类Stream进行文件的IO操作. 好用是好用, 就是总有些细节让人蛋疼. 逐步更新中. 1. Files.createFile(path)或者Files.write()时抛出NoSuchFileException这两个方法在path含有路径时, 会直接去创建目标文件, 所以当路径中间有文件夹未被创建, 就抛出此异常. 1234// 加个判断就OK了Path path = Paths.get(dir);if (!Files.exists(path)) Files.createDirectories(path); 2. java.nio.charset.MalformedInputException: Input length = 11234// Files读取文件的默认编码是UTF-8public static Stream&lt;String&gt; lines(Path path) throws IOException &#123; return lines(path, StandardCharsets.UTF_8);&#125; 通常该异常是因为读取的文件编码不是utf-8引起的. 但我这次引起是因为mac创建的DS_Store文件, 该文件是mac用于贮存目录自定义属性, 例如文件夹们的图标位置或者背景色之类. 1234// 特意的加了文件名的判断. 避免错误的解析DS_Store文件.List&lt;Path&gt; fileList = Files.list(Paths.get(basePath)) .filter(path -&gt; !Files.isDirectory(path) &amp;&amp; !path.getFileName().toString().contains("DS_Store")) .collect(Collectors.toList());]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Files</tag>
        <tag>Paths</tag>
        <tag>NoSuchFileException</tag>
        <tag>MalformedInputException</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java导出dbf格式文件]]></title>
    <url>%2Fpost%2F46831.html</url>
    <content type="text"><![CDATA[dbf文件相关属性 DBFField.FIELD_TYPE_D 表示Date型 DBFField.FIELD_TYPE_L 表示布尔型 DBFField.FIELD_TYPE_N 表示数字 DBFField.FIELD_TYPE_C 表示字符串 DBFField.FIELD_TYPE_F 表示浮点型 DBFField.FIELD_TYPE_M 不晓得,欢迎补充 jar: https://pan.baidu.com/s/1J9vuPItrNlMs2x5MYVURsw 1. 定义DBF文件字段12345678910111213141516// 字段数组DBFField[] fields = new DBFField[列的个数];// 表头---数组String[] strutName = new String[列的个数]// 数据类型 -- 数组byte[] strutType = new byte[列的个数];// 设置名称fields[i].setName(strutName[i]);// 设置类型fields[i].setDataType(strutType[i]);// 根据数据类型和数据本身指定数据长度(日期类型一般不指定长度)fields[i].setFieldLength(15);// 如果数据类型是浮点型 需要制定小数点位数 2 --&gt; 0.00fields[i].setDecimalCount(2);// 如果数据类型是数值型不需要指定小数点位数, 会直接四舍五入 2. 逐条的写入记录 123Object[] rowData = new Object[列的个数];// 如果要插入的数据是数字 但是为null 需要指定0 不可以使用空字符串和nullrowData[z] = Double.parseDouble("0"); 3. 输出文件 12345678910// 定义输出流，并关联的一个文件// 这里需要注意的是,输出dbf是在已经存在的dbf文件中覆盖写入数据.所以在定义输出流的时候必须要指定一个存在dbf文件的路径并且指定名称.File rootFile = new File(Play.applicationPath, "/public/download");OutputStream fos = new FileOutputStream(rootFile.getPath()+文件名称.dbf);// 定义 DBF输出对象DBFWriter writer = new DBFWriter();writer.setFields(fields);writer.addRecord(rowData);writer.write(fos); 4. 代码参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// 以下为系统中的代码, 仅供参考public boolean outputDBF(List&lt;PropertyFilter&gt; propertyFilterList) &#123; OutputStream fos = null; try &#123; List&lt;Object&gt; query = departinvoicesManagerDao.queryDBFinfo(propertyFilterList); String dbfName = new String("结算单管理.dbf"); StringBuffer sb = new StringBuffer(); String[] strutName = sb.append("JSRS,JSRQ,JSDH,GSDM,DWDM,DWMC,CH,JPSR,JSSR,XLF,TPF,CC,FJF,GLQF,RYFJF") .toString().split(","); byte[] strutType = new byte[15]; strutType[0] = DBFField.FIELD_TYPE_N;// JSRS strutType[1] = DBFField.FIELD_TYPE_D;// JSRQ strutType[2] = DBFField.FIELD_TYPE_C;// JSDH strutType[3] = DBFField.FIELD_TYPE_C;// GSDM strutType[4] = DBFField.FIELD_TYPE_C;// DWDM strutType[5] = DBFField.FIELD_TYPE_C;// DWMC strutType[6] = DBFField.FIELD_TYPE_C;// CH strutType[7] = DBFField.FIELD_TYPE_F;// JPSR strutType[8] = DBFField.FIELD_TYPE_F;// JSSR strutType[9] = DBFField.FIELD_TYPE_F;// XLF strutType[10] = DBFField.FIELD_TYPE_F;// TPF strutType[11] = DBFField.FIELD_TYPE_C;// CC strutType[12] = DBFField.FIELD_TYPE_F;// FJF strutType[13] = DBFField.FIELD_TYPE_F;// GLQF strutType[14] = DBFField.FIELD_TYPE_F;// RYFJF // 定义DBF文件字段 DBFField[] fields = new DBFField[15]; for (int i = 0; i &lt;= 14; i++) &#123; fields[i] = new DBFField(); fields[i].setName(strutName[i]); fields[i].setDataType(strutType[i]); // Date类型不能设置字段长度，这里没有处理其它没有字段长度的类型 if (strutType[i] == DBFField.FIELD_TYPE_C) &#123; fields[i].setFieldLength(20); &#125; else if (strutType[i] == DBFField.FIELD_TYPE_N) &#123; fields[i].setFieldLength(15); &#125; else if (strutType[i] == DBFField.FIELD_TYPE_F) &#123; fields[i].setFieldLength(15); fields[i].setDecimalCount(2); &#125; &#125; DBFWriter writer = new DBFWriter(); writer.setFields(fields); // 一条条的写入记录 for (int j = 0; j &lt; query.size(); j++) &#123; Object[] object = (Object[]) query.get(j); Object[] rowData = new Object[15]; for (int z = 0; z &lt; 15; z++) &#123; if (fields[z].getDataType() == DBFField.FIELD_TYPE_N || fields[z].getDataType() == DBFField.FIELD_TYPE_F) &#123; if (object[z] != null) &#123; rowData[z] = Double.parseDouble(object[z].toString()); &#125; else &#123; rowData[z] = Double.parseDouble("0"); &#125; &#125; else &#123; rowData[z] = object[z]; &#125; &#125; writer.addRecord(rowData); &#125; // 定义输出流，并关联的一个文件 File rootFile = new File(Play.applicationPath, "/public/download"); fos = new FileOutputStream(rootFile.getPath() + "\\" + dbfName); // 写入数据 writer.write(fos); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; fos.close(); &#125; catch (Exception e) &#123; &#125; &#125; return true; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dbf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的几种状态(笔记)]]></title>
    <url>%2Fpost%2F56550.html</url>
    <content type="text"><![CDATA[在TCP层, 有个FLAGS字段, 这个字段有以下几个标识: SYN : 建立连接, FIN : 关闭连接, ACK : 响应, PSH : 有未分片的DATA数据传输, RST : 连接重置. 其中, ACK是可能与SYN, FIN等同时使用的. 比如SYN和ACK可能同时为1, 它表示的就是建立连接之后的响应, 如果只是单个的一个SYN, 它表示的只是建立连接, TCP的几次握手就是通过这样的ACK表现出来的.但SYN与FIN是不会同时为1的, 因为前者表示的是建立连接, 而后者表示的是断开连接. RST一般是在FIN之后才会出现为1的情况, 表示的是连接重置. 一般地, 当出现FIN包或RST包时, 我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时, 我们认为客户端与服务器建立了一个连接. PSH为1的情况, 一般只出现在 DATA内容不为0的包中, 也就是说PSH为1表示的是有真正的TCP数据包内容被传递.TCP的连接建立和连接关闭, 都是通过请求－响应的模式完成的. 概念补充-TCP三次握手:TCP(Transmission Control Protocol)传输控制协议是主机对主机层的传输控制协议, 提供可靠的连接服务, 采用三次握手确认建立一个连接. 位码即tcp标志位, 有6种标示: SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急) 其他如: Sequence number(顺序号码), Acknowledge number(确认号码) 等. 第一次握手：主机A发送位码为syn＝1, 随机产生seq number=1234567的数据包到服务器, 主机B由SYN=1知道, A要求建立联机; 第二次握手: 主机B收到请求后要确认联机信息, 向A发送ack number=(主机A的seq+1), syn=1, ack=1, 随机产生seq=7654321的包; 第三次握手: 主机A收到后检查ack number是否正确, 即第一次发送的seq number+1, 以及位码ack是否为1, 若正确, 主机A会再发送ack number=(主机B的seq+1), ack=1, 主机B收到后确认seq值与ack=1则连接建立成功. 完成三次握手, 主机A与主机B开始传送数据. 在TCP/IP协议中, TCP协议提供可靠的连接服务, 采用三次握手建立一个连接. 第一次握手: 建立连接时, 客户端发送syn包(syn=j)到服务器, 并进入SYN_SEND状态, 等待服务器确认; 第二次握手: 服务器收到syn包, 必须确认客户的SYN（ack=j+1）, 同时自己也发送一个SYN包（syn=k）, 即SYN+ACK包, 此时服务器进入SYN_RECV状态； 第三次握手: 客户端收到服务器的SYN＋ACK包, 向服务器发送确认包ACK(ack=k+1), 此包发送完毕, 客户端和服务器进入ESTABLISHED状态, 完成三次握手. 完成三次握手, 客户端与服务器开始传送数据. 摘自中国云安网, 原文链接:http://www.yunsec.net/a/school/wlcs/agreement/2012/0317/10262.html]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在VPS上搭建ss或v2ray]]></title>
    <url>%2Fpost%2F52793.html</url>
    <content type="text"><![CDATA[ss当初购买的是vultr的服务器, 系统为CentOs7 X64v2ray是用的Google Cloud, 俗称GCP, 系统同为CentOs7 X64 ss一般linux都会带python, 就不写怎么安装了. 12345678910111213141516171819202122232425# 使用pip安装shadowsockspip install shadowsocks# 创建并编辑配置mkdir /etc/shadowsocksvim /etc/shadowsocks/config.json# 添加配置(多端口)&#123; "server":"VPS的外网IP地址", "local_address":"127.0.0.1", # 本地代理地址, 默认就好 "local_port":1080, # 本地代理端口 "port_password": &#123; "端口1":"密码1", "端口2":"密码2", "端口3":"密码3" &#125;, "timeout":300, # 超时时间 "method":"aes-256-cfb", # 加密算法 "fast_open":false&#125;# 启动方式ssserver -c /etc/shadowsocks/config.json -d start 后台启动ssserver -c /etc/shadowsocks/config.json -d stop 后台停止 v2ray官网地址: https://www.v2ray.com12# 执行shell脚本即可, 一键安装bash &lt;(curl -L -s https://install.direct/go.sh) 此脚本会自动安装以下文件: /usr/bin/v2ray/v2ray：V2Ray 程序； /usr/bin/v2ray/v2ctl：V2Ray 工具； /etc/v2ray/config.json：配置文件； /usr/bin/v2ray/geoip.dat：IP 数据文件 /usr/bin/v2ray/geosite.dat：域名数据文件 此脚本会配置自动运行脚本. 自动运行脚本会在系统重启之后, 自动运行 V2Ray.目前自动运行脚本只支持带有 Systemd 的系统, 以及 Debian / Ubuntu 全系列. 运行脚本位于系统的以下位置: /etc/systemd/system/v2ray.service: Systemd /etc/init.d/v2ray: SysV 脚本运行完成后，你需要： 编辑 /etc/v2ray/config.json 文件来配置你需要的代理方式； 运行 service v2ray start 来启动 V2Ray 进程； 之后可以使用 service v2ray start|stop|status|reload|restart|force-reload 控制 V2Ray 的运行。 TCP加速Google BBR是一种新兴的TCP单边加速方案, 建议开启BBR加速算法123wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 其他注意事项 如果用的是像阿里云, Google Cloud, 腾讯云, AWS等云平台, 记得开放端口. 如果你的镜像里没有pip, 但是有python, 那就装一个. 12345# 如果连wget都没有, 像Google Cloud提供的CentOS就比较干净.yum install wgetwget https://bootstrap.pypa.io/get-pip.pypython get-pip.py# 如果连python都没有, 百度吧 端口个数看使用情况定, 通常来说几个人用就开几个端口.]]></content>
      <categories>
        <category>梯子</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>v2ray</tag>
      </tags>
  </entry>
</search>
